{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":"<p>GeoServer Cloud is a cloud-ready version of GeoServer that leverages dockerized microservices for deployment.</p> <p>The GeoServer Cloud project decomposes GeoServer's geospatial services and API offerings into individually deployable components within a microservices-based architecture. This project incorporates practical enhancements to GeoServer based on extensive experience with GeoServer clustering solutions.</p> <p>Built with GeoServer software components, GeoServer Cloud adapts and/or extends these components using a functional decomposition by business capability approach. As a result, each service (e.g., OWS service, Web UI, REST API) is available as a self-contained, individually deployable, and scalable microservice.</p> <p>Q: Does this mean GeoServer's <code>.war</code> file is deployed multiple times, with each instance exposing a specific \"business capability\"?</p> <p>Absolutely not. This is not a clustered GeoServer approach and does not use <code>.war</code> files. Each microservice is a self-contained application that includes only the GeoServer components necessary for the service. Many GeoServer components provide extensive functionality (such as different output formats). In these cases, care is taken to load only the functionality required for a lightweight experience.</p>"},{"location":"#background-and-motivation","title":"Background and Motivation","text":"<p>GeoServer is the most widely used and deployed open-source geospatial server in the world. It enables the publishing, transformation, and editing of geospatial data from numerous formats through a comprehensive set of user-facing services. In addition to these out-of-the-box capabilities, GeoServer supports over 40 extensions, along with numerous experimental extensions (known as \"community modules\").</p> <p>As a monolithic application, GeoServer's installation and configuration are straightforward, as all its components are bundled together, providing a cohesive approach to software delivery.</p> <p>However, deploying and maintaining GeoServer instances often presents common challenges, such as server dimensioning, configuration, system health monitoring, and corrective actions. These difficulties increase as systems need to handle higher request loads, ensure service availability, and maintain overall performance.</p> <p>Traditional deployments, while capable of providing high availability, often require a fixed number of application instances, a single-master/multiple-slave cluster architecture, and/or additional components to keep instances in sync.</p> <p>Ensuring adequate load capacity often results in over-provisioning of server resources to handle demand peaks, which can negatively impact an organization's budget, especially when deploying on public cloud providers like Amazon AWS, Microsoft Azure, or Google Cloud Platform.</p> <p>While a gateway/load balancer can make cluster instances auto-scalable, all instances expose the entire set of GeoServer functionalities, regardless of which services are in high demand. This can lead to unnecessary resource consumption, open attack vectors, and the loss of unrelated capabilities when a component fails.</p>"},{"location":"#vision","title":"Vision","text":"<p>GeoServer Cloud is a sibling project to GeoServer, targeting organizations and system administrators seeking a reliable and prescribed way of provisioning GeoServer capabilities in a dynamic environment. In this environment, each business capability can be enabled, configured, dimensioned, and deployed independently.</p> <p>GeoServer Cloud is not a re-write of GeoServer. Instead, it builds on existing GeoServer software components, adapting and/or extending them, and contributing back to GeoServer's mainline development. Traditional GeoServer installations are still recommended for simple deployments that need to expose all capabilities.</p> <p>This project reformulates how these capabilities are bundled together, aiming to achieve functional decomposition by business capability. This means each OWS service, the Web UI, the REST API, and other components such as the Catalog and Configuration subsystem become self-contained, individually deployable, and scalable microservices, loosely coupled through an event-based architecture.</p> <p>These containerized applications support various deployment strategies, ranging from single-server Docker compositions to multi-node deployments using Docker Swarm or Kubernetes.</p>"},{"location":"#goals-and-benefits","title":"Goals and Benefits","text":"<ul> <li>Provide guidelines for proper dimensioning of services based on their resource needs and performance characteristics.</li> <li>Enable independent evolution of services.</li> <li>Externalize and centralize configuration of services and their sub-components.</li> <li>Isolate services to ensure system continuity in the event of specific service unavailability.</li> <li>Implement per-service auto-scaling.</li> <li>Support continuous delivery workflows.</li> <li>Achieve location transparency of service instances in a dynamic environment. A \"gateway\" service acts as a single entry point, dispatching requests to the appropriate microservices using a round-robin load-balanced configuration.</li> <li>Centralize service logging, request tracing, and monitoring.</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>The following instructions provide a quick start guide to running the system as a Docker composition on a single machine. For advanced deployment options and strategies, refer to the Deployment Guide.</p> <p>These instructions assume you have Docker Engine, Docker CLI, and the Compose Plugin installed.</p> <p>GeoServer Cloud can run with various GeoServer catalog and configuration storage backends. For scalability, we recommend using our PostgreSQL backend, <code>pgconfig</code>.</p> <p>Download the Docker Compose file to a directory on your computer:</p> <pre><code>wget \"http://geoserver.org/geoserver-cloud/deploy/docker-compose/stable/pgconfig/compose.yml\"\n</code></pre> <p>Open a terminal, navigate to the directory where you downloaded the file, and run docker compose pull to fetch the Docker images from Docker Hub:</p> <pre><code>docker compose pull\nPulling rabbitmq  ... done\nPulling database  ... done\nPulling discovery ... done\nPulling config    ... done\nPulling gateway   ... done\nPulling catalog   ... done\nPulling wfs       ... done\nPulling wms       ... done\nPulling wcs       ... done\nPulling gwc       ... done\nPulling rest      ... done\nPulling webui     ... done\nPulling acl       ... done\n</code></pre> <p>Then start the services with this command:</p> <pre><code>docker compose up -d\n</code></pre> <p>Wait for the services to start. Check their status with:</p> <pre><code>docker compose ps\n</code></pre> <p>If any service has exited, re-run docker compose up -d. Initial startup may cause timeouts as services compete for resources on a single machine.</p> <p>Then browse to:</p> <ul> <li>http://localhost:8761 to access the Discovery service registry page.</li> <li>http://localhost:9090 for the GeoServer UI. The Gateway service will proxy requests to the appropriate microservice.</li> </ul> <p>From a usability perspective, there should be no significant differences compared to a traditional GeoServer deployment.</p> <p>In this local-machine cluster, each GeoServer business capability runs as a separate process in a dedicated Docker container. These containers synchronize in a loosely coupled manner using a message-driven event bus.</p> <p>For Docker Compose deployments, we use: - Eureka Discovery Service: For service discovery and client-side load balancing - Config Server: For centralized configuration management - RabbitMQ: For event bus communication between services</p> <p>Experiment with dynamic service scaling and registration using <code>docker compose scale &lt;service&gt;=&lt;instances&gt;</code>. For example:</p> <pre><code>docker compose scale wfs=3 wcs=0\nStarting gscloud_wfs_1 ... done\nCreating gscloud_wfs_2 ... done\nCreating gscloud_wfs_3 ... done\nStopping and removing gscloud_wcs_1 ... done\n</code></pre> <p>Note: For Kubernetes deployments, a different approach is recommended. Use the <code>standalone</code> Spring profile and leverage Kubernetes Services for service discovery and load balancing instead of Eureka. This allows Kubernetes to handle load balancing natively and is more efficient for cloud deployments.</p>"},{"location":"#technology-overview","title":"Technology Overview","text":"<p>Given GeoServer is a traditional, Spring Framework based, monolithic Servlet/WebMVC application, GeoServer Cloud microservices are logically based on the Spring Boot framework.</p> <p>Additionally, Spring Cloud technologies enable crucial capabilities such as dynamic service discovery, externalized configuration, distributed events, API gateway, and more.</p> <p>Only a curated list of the vast amount number of GeoServer extensions will be supported, as they are verified and potentially adapted to work with this project's architecture.</p>"},{"location":"#system-architecture-overview","title":"System Architecture Overview","text":"<p>The following diagram depicts the system's general architecture:</p> <p></p> <ul> <li>Hexagons represent microservices.</li> <li>Colored rectangles represent logical groupings of components.</li> <li>Lines connecting a group to another component indicate that the connector applies to all services of the outgoing end and to all components of the incoming end.</li> <li>White rectangles represent components that are platform/deployment choices. For example:<ul> <li>\"Event bus\" could be a cloud infrastructure provider's native service (event queue) or a microservice implementing a distributed event broker.</li> <li>\"Catalog/Config backend\" is the software component used to access the catalog and configuration. It might be a microservice itself, a catalog/config provider for a \"data directory\", a database, or another external service store, depending on the available catalog/config backend implementations and how they're configured and provisioned.</li> <li>\"Catalog/Config storage\" is the storage mechanism that backs the catalog/config software component. It might a shared \"data  directory\" or database, a \"per instance\" data directory or database, and so on, depending on the available catalog/config backend implementations, and how they're configured and provisioned.</li> <li>\"Geospatial data sources\" is whatever method is used to access the actual data served up by the microservices.</li> </ul> </li> </ul>"},{"location":"#project-status","title":"Project Status","text":"<p>Version <code>2.28.2.0</code> has been released against a slightly customized GeoServer <code>2.28.2</code> with some important fixes to allow starting up several GeoServer instances from an empty directory or database. We will make sure to contribute those fixes upstream before the final release.</p> <p>GeoServer Cloud is production ready. It is currently used by several private companies and public authorities in Europe. It has been deployed successfully on AWS, Azure, GKE, OpenShift and Scaleway.</p>"},{"location":"community/","title":"Community","text":"<p>Welcome to the GeoServer Cloud community! We're glad you're here.</p> <p>GeoServer Cloud is an open-source project that thrives on community collaboration. Whether you're a developer, user, tester, designer, or advocate, there's a place for you here.</p>"},{"location":"community/#get-involved","title":"Get Involved","text":"<p>There are many ways to contribute to GeoServer Cloud:</p> <ul> <li>Report bugs and request features through GitHub Issues</li> <li>Contribute code by submitting pull requests</li> <li>Improve documentation to help others understand and use GeoServer Cloud</li> <li>Answer questions and help other users</li> <li>Test new features and provide feedback</li> <li>Share your experience through blog posts, talks, or social media</li> <li>Support the project financially or through business partnerships</li> </ul>"},{"location":"community/#community-resources","title":"Community Resources","text":""},{"location":"community/#contributors","title":"Contributors","text":"<p>See our amazing contributors who make this project possible. We recognize all types of contributions, not just code!</p>"},{"location":"community/#contributing-guide","title":"Contributing Guide","text":"<p>Learn how to contribute to GeoServer Cloud, including:</p> <ul> <li>Pull request workflow</li> <li>Commit guidelines</li> <li>Code contribution license agreement</li> <li>Development setup</li> </ul>"},{"location":"community/#code-of-conduct","title":"Code of Conduct","text":"<p>Our community pledge and standards for inclusive, welcoming participation.</p>"},{"location":"community/#communication","title":"Communication","text":"<ul> <li>GitHub Discussions: Ask questions, share ideas, and discuss the project</li> <li>GitHub Issues: Report bugs and request features</li> <li>Pull Requests: Contribute code and documentation</li> </ul>"},{"location":"community/#recognition","title":"Recognition","text":"<p>We believe that all contributions are valuable. That's why we use the All Contributors specification to recognize everyone who contributes to the project, regardless of the type of contribution.</p> <p>Visit our Contributors page to see everyone who has helped make GeoServer Cloud better!</p>"},{"location":"community/#support","title":"Support","text":"<p>If you need help:</p> <ol> <li>Check the documentation for guides and references</li> <li>Search existing issues to see if your question has been answered</li> <li>Open a new issue if you've found a bug or have a feature request</li> <li>Reach out to the community through GitHub Discussions</li> </ol> <p>Thank you for being part of the GeoServer Cloud community!</p>"},{"location":"community/contributors/","title":"Contributors","text":"<p>This project follows the All Contributors specification. We recognize contributions of all kinds - not just code!</p>"},{"location":"community/contributors/#our-amazing-contributors","title":"Our Amazing Contributors","text":"<p>Thanks goes to these wonderful people (emoji key):</p> <sub>Adrien VAN HAMME</sub>\ud83d\udcbc \ud83e\udd14 \ud83d\udce3 \ud83d\udd0d <sub>Alexandre Gacon</sub>\ud83d\udcd6 \ud83d\udc1b \u26a0\ufe0f \ud83e\udd14 \ud83d\udcac \ud83c\udf0d <sub>Andrea Borghi</sub>\ud83d\ude87 \ud83d\udc1b \u26a0\ufe0f \ud83d\udcbb \ud83d\udce2 \ud83d\udcd3 <sub>C\u00e9cile Vuilleumier</sub>\ud83d\udcbb \ud83d\udc1b \u26a0\ufe0f \ud83d\ude87 \ud83d\udc40 <sub>Daniel Koch</sub>\ud83d\udcbb \ud83d\udd0c \ud83d\udc1b \u26a0\ufe0f \ud83d\udce2 <sub>Emmanuel Belo</sub>\ud83d\udd0d \ud83d\udce3 \ud83d\udcbc <sub>Florent Gravin</sub>\ud83d\udcbc \ud83e\udd14 \ud83d\udce3 \ud83d\udd0d <sub>Gabriel Roldan</sub>\ud83d\udcbb \ud83d\udcd6 \ud83d\ude87 \ud83c\udfa8 \ud83e\udd14 \ud83d\udea7 \ud83d\udd2c \ud83d\udce2 <sub>Guspan Tanadi</sub>\ud83d\udcd6 <sub>Herman</sub>\ud83d\udcd6 \ud83d\udcd3 \ud83d\udc1b <sub>Jose Macchi</sub>\ud83d\udc1b \u26a0\ufe0f \ud83d\ude87 \ud83d\udc40 <sub>L\u00e9o Depriester</sub>\ud83d\ude87 <sub>Marc Jansen</sub>\ud83d\udcd6 \ud83d\udcd3 <sub>Marco Lechner</sub>\ud83d\udcd3 <sub>Mickael Lehoux</sub>\ud83d\udc1b \ud83d\udcd3 <sub>Nils B\u00fchner</sub>\ud83d\udcbb \ud83d\udd0c \ud83d\udc1b \u26a0\ufe0f \ud83d\udce2 <sub>Olivia Guyot</sub>\ud83d\udcd6 \ud83d\udcd3 \ud83d\udc1b \ud83d\udcbb <sub>Pierre Mauduit</sub>\ud83d\udcd6 \ud83d\udcd3 \ud83d\udc1b \ud83d\udcbb <sub>Przemyslaw Pradela</sub>\ud83d\udcd6 <sub>Wolfgang Kaltz</sub>\ud83d\udcd6 \ud83d\udcc6 \ud83d\udcbc \ud83d\udce3 <sub>Wouter Goedhart</sub>\ud83d\udc1b \ud83d\udd0c \ud83d\udcbb <sub>allanin</sub>\ud83d\udcd6 \u26a0\ufe0f <sub>amjobst</sub>\ud83d\udcbc \ud83e\udd14 \ud83d\udce3 \ud83d\udd0d \ud83d\udcc6 <sub>shacharmo</sub>\ud83d\udc1b \ud83d\udcbb"},{"location":"community/contributors/#how-to-get-recognized","title":"How to Get Recognized","text":"<p>We use the All Contributors bot to recognize contributors. There are two ways to be added:</p>"},{"location":"community/contributors/#for-code-github-activity","title":"For Code &amp; GitHub Activity","text":"<p>If you've contributed through GitHub (code, issues, reviews, etc.), you can request to be added:</p> <ol> <li>Comment on any issue or PR: <code>@all-contributors please add @username for &lt;contribution-type&gt;</code></li> <li>The bot will create a PR adding you to the list</li> <li>Once merged, you'll appear on this page!</li> </ol> <p>Contribution types include:</p> Type Emoji Description code \ud83d\udcbb Code contributions doc \ud83d\udcd6 Documentation bug \ud83d\udc1b Bug reports test \u26a0\ufe0f Tests infra \ud83d\ude87 Infrastructure (CI/CD, build tools, etc.) design \ud83c\udfa8 Design work ideas \ud83e\udd14 Ideas &amp; Planning review \ud83d\udc40 Code reviews question \ud83d\udcac Answering questions maintenance \ud83d\udea7 Maintenance example \ud83d\udca1 Examples tutorial \u2705 Tutorials translation \ud83c\udf0d Translation talk \ud83d\udce2 Talks &amp; presentations video \ud83d\udcf9 Videos plugin \ud83d\udd0c Plugin development userTesting \ud83d\udcd3 User testing content \ud83d\udd8b Content creation eventOrganizing \ud83d\udccb Event organizing mentoring \ud83e\uddd1\u200d\ud83c\udfeb Mentoring research \ud83d\udd2c Research business \ud83d\udcbc Business development financial \ud83d\udcb5 Financial support projectManagement \ud83d\udcc6 Project management promotion \ud83d\udce3 Promoting the project security \ud83d\udee1\ufe0f Security work fundingFinding \ud83d\udd0d Funding finding <p>See the complete list at allcontributors.org/emoji-key.</p>"},{"location":"community/contributors/#manual-addition","title":"Manual Addition","text":"<p>Some contributions (like business development, financial support, or project management) may not show up in GitHub activity. For these contributions, contact the maintainers to be manually added to the <code>.all-contributorsrc</code> file.</p>"},{"location":"community/contributors/#why-all-contributors","title":"Why All Contributors?","text":"<p>We believe that all contributions matter. Whether you:</p> <ul> <li>Fixed a typo in the docs</li> <li>Reported a critical bug</li> <li>Answered a question on GitHub</li> <li>Gave a talk about GeoServer Cloud</li> <li>Provided financial support</li> <li>Managed project priorities</li> <li>Or anything else that helped the project</li> </ul> <p>You deserve recognition! \ud83c\udf89</p> <p>This page celebrates everyone who has helped make GeoServer Cloud better. Thank you!</p> <p>This project follows the All Contributors specification. Contributions of any kind are welcome!</p>"},{"location":"configuration/","title":"Cloud Native GeoServer externalized configuration guide","text":""},{"location":"configuration/#introduction","title":"Introduction","text":"<p>GeoServer Cloud provides extensive configuration options through Spring Boot's externalized configuration system. This document outlines the various configuration options available for customizing your GeoServer Cloud deployment.</p>"},{"location":"configuration/#jndi-datasources","title":"JNDI Datasources","text":"<p>A custom and very simple JNDI implementation is used through the <code>org.geoserver.cloud:spring-boot-simplejndi</code> maven module, allowing to configure JNDI data sources through Spring-Boot's configuration properties.</p> <pre><code>jndi:\n  datasources:\n    # the data source names (i.e. ds1, ds2) will be bound as java:comp/env/jdbc/ds1 and java:comp/env/jdbc/ds2:\n    ds1:\n      enabled: true\n      wait-for-it: true\n      wait-timeout: 60\n      url: jdbc:postgresql://host:5432/database\n      username: sa\n      password: sa\n      connection-timeout: 250\n      idle-timeout: 60000\n</code></pre> <p>On Kubernetes, you can for example mount it as a config map in all the services.</p>"},{"location":"configuration/#geoserver-configuration-properties","title":"GeoServer configuration properties","text":""},{"location":"configuration/#http-proxy-for-cascaded-ows-wmswmtswfs-stores","title":"HTTP proxy for cascaded OWS (WMS/WMTS/WFS) Stores","text":"<p>Cascaded OWS stores make use of a SPI (Service Provider Interface) extension point to configure the appropriate GeoTools <code>HTTPClientFactory</code>.</p> <p>We provide a Spring Boot Auto-configuration that can be configured through regular spring-boot externalized properties and only affects GeoTools HTTP clients instead of the whole JVM.</p> <p>The usual way to set an http proxy is through the <code>http.proxyHost</code>, <code>http.proxyPort</code>, <code>http.proxyUser</code>, <code>http.proxyPassword</code> Java System Properties.</p> <p>In the context of Cloud Native GeoServer containerized applications, this presents a number of drawbacks:</p> <ul> <li>Standard Java proxy parameters only work with System properties,   not OS environment variables, and setting system properties is more   cumbersome than env variables (you have to modify the container run command).</li> <li><code>http.proxyUser/Password</code> are not standard properties, though commonly used, it's kind of JDK implementation dependent.</li> <li>Setting `-Dhttp.proxy* System properties affects all HTTP clients in the container, meaning requests to the config-service, discovery-service, etc., will also try to go through the proxy, or you need to go through the extra burden of figuring out how to ignore them.</li> <li>If the proxy is secured, and since the http client used may not respect the http.proxyUser/Password parameters, the apps won't start since they'll get HTTP 407 \"Proxy Authentication Required\".</li> </ul> <p>The following externalized configuration properties apply, with these suggested default values:</p> <pre><code># GeoTools HTTP Client proxy configuration, allows configuring cascaded WMS/WMTS/WFS stores\n# that need to go through an HTTP proxy without affecting all the http clients at the JVM level\n# These are default settings. The enabled property can be set to false to disable the custom\n# HTTPClientFactory altogether.\n# The following OS environment variables can be set for easier configuration:\n# HTTP(S)_PROXYHOST, HTTP(S)_PROXYPORT, HTTP(S)_PROXYUSER, HTTP(S)_PROXYPASSWORD, HTTP(S)_NONPROXYHOSTS\ngeotools:\n  httpclient:\n    proxy:\n      enabled: true\n      http:\n        host: ${http.proxyHost:}\n        port: ${http.proxyPort:}\n        user: ${http.proxyUser:}\n        password: ${http.proxyPassword:}\n        nonProxyHosts: ${http.nonProxyHosts:localhost.*}\n        # comma separated list of Java regular expressions, e.g.: nonProxyHosts: localhost, example.*\n      https:\n        host: ${https.proxyHost:${geotools.httpclient.proxy.http.host}}\n        port: ${https.proxyPort:${geotools.httpclient.proxy.http.port}}\n        user: ${https.proxyUser:${geotools.httpclient.proxy.http.user}}\n        password: ${https.proxyPassword:${geotools.httpclient.proxy.http.password}}\n        nonProxyHosts: ${https.nonProxyHosts:${geotools.httpclient.proxy.http.nonProxyHosts}}\n</code></pre>"},{"location":"configuration/#configure-http-proxy-with-environment-variables-in-composeyml","title":"Configure HTTP proxy with environment variables in compose.yml","text":"<p>As mentioned above, regular JVM proxy configuration works with Java System properties but not with Operating System environment variables.</p> <p>The above <code>geotools.httpclient.proxy</code> config properties though allow to do so easily as in the following <code>compose.yml</code> snippet:</p> <pre><code>version: \"3.8\"\n...\nservices:\n...\n  wms:\n    image: geoservercloud/geoserver-cloud-wms:&lt;version&gt;\n    environment:\n      HTTP_PROXYHOST: 192.168.86.26\n      HTTP_PROXYPORT: 80\n      HTTP_PROXYUSER: jack\n      HTTP_PROXYPASSWORD: insecure\n...\n</code></pre>"},{"location":"configuration/#configure-admin-user-through-environment-variables","title":"Configure admin user through environment variables","text":"<p>For Cloud-Native deployments, an <code>AuthenticationProvider</code> exists that allows to set an administrator account (username and password) through environment variables <code>GEOSERVER_ADMIN_USERNAME</code>/<code>GEOSERVER_ADMIN_PASSWORD</code>, or Java System Properties <code>geoserver.admin.username</code> and <code>geoserver.admin.password</code>.</p> <p>Useful for devOps to set the admin password through a Kubernetes secret, instead of having to tweak the security configuration XML files with an init container or similar.</p> <p>This authentication provider will be the first one tested for an HTTP Basic authorization, only if both the above mentioned username and password config properties are provided, and regardless of the authentication chain configured in GeoServer.</p> <p>If only one of the <code>geoserver.admin.username</code> and <code>geoserver.admin.password</code> config properties is provided, the application will fail to start.</p> <p>If enabled (i.e. both admin username and password provided), a failed attempt to log in will cancel the authentication chain, and no other authentication providers will be tested.</p> <p>If the default <code>admin</code> username is used, it effectively overrides the admin password set in the xml configuration. If a separate administrator username is given, the regular <code>admin</code> user is disabled.</p>"},{"location":"configuration/#change-the-default-geoserver-path","title":"Change the default geoserver path","text":"<p>By default, GeoServer Cloud services are available under <code>geoserver/cloud/web</code> path. You can change it by using the <code>GEOSERVER_BASE_PATH</code> or Java System Properties <code>geoserver.base-path</code>.</p>"},{"location":"configuration/#use-geoserver-acl","title":"Use GeoServer ACL","text":"<p>To use GeoServer ACL with GeoServer Cloud, you need to do the following steps: - Have a database available for storing the GeoServer ACL configuration - Add a GeoServer ACL instance to your deployment - Update the GeoServer spring configuration to enable ACL based security (you can use the <code>acl</code> spring profile)</p>"},{"location":"configuration/#use-oauth-authentication","title":"Use OAuth authentication","text":"<p>You can enable OAuth authentication by replacing the default <code>gateway</code> image by the geOrchestra gateway (for example <code>georchestra/gateway:23.1-RC1</code>).</p>"},{"location":"configuration/#filter-vector-and-raster-data-formats","title":"Filter vector and raster data formats","text":"<p>GeoServer Cloud provides the ability to filter which GeoTools DataAccessFactory (vector) and GridFormatFactorySpi (raster) implementations are available in the application. This allows you to customize each deployment to only include the formats you need, improving security, reducing the attack surface, and potentially improving startup time.</p>"},{"location":"configuration/#configuration-properties","title":"Configuration properties","text":"<p>The following configuration properties can be used to control which formats are available:</p> <pre><code>geotools:\n  data:\n    filtering:\n      # Master switch for the entire filtering system\n      enabled: true\n\n      # Vector format configuration (DataAccessFactory implementations)\n      vector-formats:\n        \"[PostGIS]\": true\n        \"[Shapefile]\": true\n        \"[GeoPackage]\": true\n        \"[Oracle NG]\": ${oracle.enabled:false}\n        \"[Web Feature Server (NG)]\": true\n        \"[Microsoft SQL Server]\": false\n        # Add more vector format entries as needed\n\n      # Raster format configuration (GridFormatFactorySpi implementations)\n      raster-formats:\n        \"[GeoTIFF]\": true\n        \"[ImageMosaic]\": ${mosaic.enabled:true}\n        \"[ArcGrid]\": false\n        \"[WorldImage]\": true\n        \"[ImagePyramid]\": false\n        # Add more raster format entries as needed\n</code></pre>"},{"location":"configuration/#format-names","title":"Format names","text":"<p>The format names used in the configuration are the user-friendly display names returned by the respective factories:</p> <ul> <li>For vector formats: The name returned by <code>DataAccessFactory.getDisplayName()</code></li> <li>For raster formats: The name returned by <code>AbstractGridFormat.getName()</code></li> </ul> <p>Since these names often contain special characters, they should be properly escaped in the YAML configuration using quotes and brackets.</p>"},{"location":"configuration/#placeholder-resolution","title":"Placeholder resolution","text":"<p>Both vector and raster format configurations support Spring property placeholder resolution, allowing you to create dynamic configurations using environment variables or system properties. For example:</p> <pre><code>vector-formats:\n  \"[Oracle NG]\": ${oracle.enabled:false}\n  \"[PostGIS]\": ${postgis.enabled:true}\n</code></pre> <p>This will enable the Oracle format only if the <code>oracle.enabled</code> property is set to <code>true</code>, otherwise it will default to <code>false</code>.</p>"},{"location":"configuration/#implementation-details","title":"Implementation details","text":"<p>The filtering system uses different approaches for vector and raster formats:</p> <ul> <li>Vector formats: Directly deregisters disabled DataAccessFactory implementations using <code>DataAccessFinder.deregisterFactory()</code> and <code>DataStoreFinder.deregisterFactory()</code></li> <li>Raster formats: Uses a custom FilteringFactoryCreator wrapper around the standard GridFormatFinder registry to filter formats on-the-fly</li> </ul> <p>For more details, refer to the README files in the respective starter modules: - Input formats: <code>src/starters/input-formats/README.md</code></p>"},{"location":"configuration/migration-2.26-to-2.27/","title":"Migrating from GeoServer Cloud 2.26.x to 2.27.0.0","text":"<p>This guide outlines the key configuration changes when upgrading from GeoServer Cloud 2.26.x to 2.27.0.0.</p> <p>Important Note: All configuration changes described in this document are already incorporated as the new defaults in each GeoServer Docker image's <code>/etc/geoserver/geoserver.yml</code> externalized configuration file. You only need to adjust these settings if you were using custom configurations that differ from the defaults.</p>"},{"location":"configuration/migration-2.26-to-2.27/#configuration-property-changes","title":"Configuration Property Changes","text":""},{"location":"configuration/migration-2.26-to-2.27/#extension-configuration-structure","title":"Extension Configuration Structure","text":"<p>The most significant change is the reorganization of extension configuration properties under a unified <code>geoserver.extension</code> namespace. This improves configuration organization and consistency.</p>"},{"location":"configuration/migration-2.26-to-2.27/#old-structure-226x","title":"Old Structure (2.26.x)","text":"<pre><code>geoserver:\n  styling:\n    css.enabled: true\n    mapbox.enabled: true\n  security:\n    authkey: true\n    jdbc: true\n    ldap: true\n    gateway-shared-auth:\n      enabled: ${gateway.shared-auth:true}\n      auto: true\n      server: false\n  wms:\n    output-formats:\n      vector-tiles:\n        mapbox.enabled: true\n        geojson.enabled: true\n        topojson.enabled: true\n</code></pre>"},{"location":"configuration/migration-2.26-to-2.27/#new-structure-22700","title":"New Structure (2.27.0.0)","text":"<pre><code>geoserver:\n  extension:\n    css-styling:\n      enabled: true\n    mapbox-styling:\n      enabled: true\n    vector-tiles:\n      enabled: true\n      mapbox: true\n      geojson: true\n      topojson: true\n    dxf:\n      enabled: true\n    flatgeobuf:\n      enabled: true\n    importer:\n      enabled: false\n    security:\n      auth-key:\n        enabled: ${geoserver.security.authkey:true}\n      jdbc:\n        enabled: ${geoserver.security.jdbc:true}\n      ldap:\n        enabled: ${geoserver.security.ldap:true}\n      geonode-oauth2:\n        enabled: ${geoserver.security.geonode.enabled:true}\n      environment-admin:\n        enabled: ${geoserver.security.environment-admin.enabled:true}\n      gateway-shared-auth:\n        enabled: ${geoserver.security.gateway-shared-auth.enabled:true}\n        auto: ${geoserver.security.gateway-shared-auth.auto:true}\n</code></pre>"},{"location":"configuration/migration-2.26-to-2.27/#webui-extension-configuration","title":"WebUI Extension Configuration","text":"<p>The WebUI service configuration for the importer extension has changed:</p>"},{"location":"configuration/migration-2.26-to-2.27/#old-structure-226x_1","title":"Old Structure (2.26.x)","text":"<pre><code>geoserver:\n  web-ui:\n    extensions:\n      importer.enabled: ${webui.importer.enabled:false}\n</code></pre>"},{"location":"configuration/migration-2.26-to-2.27/#new-structure-22700_1","title":"New Structure (2.27.0.0)","text":"<p>The importer extension is now managed through the common extension configuration:</p> <pre><code>geoserver:\n  extension:\n    importer:\n      enabled: false  # Set to true to enable\n</code></pre>"},{"location":"configuration/migration-2.26-to-2.27/#data-format-filtering","title":"Data Format Filtering","text":"<p>A new capability has been added for filtering vector and raster data formats. This allows you to control which data formats are available in your GeoServer instance:</p> <pre><code>geotools:\n  data:\n    filtering:\n      enabled: true\n      vector-formats:\n        \"[PostGIS]\": true\n        \"[Shapefile]\": true\n        \"[GeoPackage]\": true\n        \"[Oracle NG]\": ${oracle.enabled:false}\n        # Add more formats as needed\n      raster-formats:\n        \"[GeoTIFF]\": true\n        \"[ImageMosaic]\": ${mosaic.enabled:true}\n        \"[ArcGrid]\": false\n        # Add more formats as needed\n</code></pre>"},{"location":"configuration/migration-2.26-to-2.27/#removed-properties","title":"Removed Properties","text":"<p>The following properties have been removed:</p> <ul> <li><code>geoserver.backend.data-directory.parallel-loader</code>: This property is no longer used as the optimization is always enabled.</li> </ul>"},{"location":"configuration/migration-2.26-to-2.27/#migration-steps","title":"Migration Steps","text":"<p>To migrate your custom configuration:</p> <ol> <li> <p>No Action Required for Default Setups: If you're using the Docker images with default configurations, no changes are needed.</p> </li> <li> <p>For Custom Configurations:</p> </li> </ol> <p>a. Update Extension Configuration: Move all extension-specific configuration properties under the <code>geoserver.extension</code> namespace, following the new structure.</p> <p>b. Update Security Configuration: Move security extension properties from <code>geoserver.security</code> to <code>geoserver.extension.security</code>.</p> <p>c. Update WebUI Service Configuration: If using the importer extension in WebUI, switch to the global extension configuration.</p> <p>d. Add Data Format Filtering: Consider adding data format filtering to limit which formats are available in your deployment.</p> <p>e. Review Removed Properties: Remove any references to removed properties.</p>"},{"location":"configuration/migration-2.26-to-2.27/#example-migration","title":"Example Migration","text":"<p>Here's a simplified example of migrating from the old to the new configuration format:</p>"},{"location":"configuration/migration-2.26-to-2.27/#old-configuration-226x","title":"Old Configuration (2.26.x)","text":"<pre><code>geoserver:\n  styling:\n    css.enabled: true\n    mapbox.enabled: true\n  security:\n    authkey: true\n    jdbc: true\n    gateway-shared-auth:\n      enabled: true\n  wms:\n    output-formats:\n      vector-tiles:\n        mapbox.enabled: true\n</code></pre>"},{"location":"configuration/migration-2.26-to-2.27/#new-configuration-22700","title":"New Configuration (2.27.0.0)","text":"<pre><code>geoserver:\n  extension:\n    css-styling:\n      enabled: true\n    mapbox-styling:\n      enabled: true\n    vector-tiles:\n      enabled: true\n      mapbox: true\n    security:\n      auth-key:\n        enabled: true\n      jdbc:\n        enabled: true\n      gateway-shared-auth:\n        enabled: true\n</code></pre>"},{"location":"configuration/migration-2.26-to-2.27/#additional-notes","title":"Additional Notes","text":"<ul> <li>The new structure provides better categorization and organization of extensions</li> <li>Extension configuration is now consistent across all extension types</li> <li>Default values remain the same for most properties</li> <li>Several new extensions have been added: DXF, FlatGeobuf, and Importer</li> <li>Environment-based admin authentication is now configurable through <code>geoserver.extension.security.environment-admin</code></li> <li>All these changes are automatically applied in the Docker images' default configuration files - manual changes are only needed if you're using custom configurations</li> </ul>"},{"location":"configuration/migration-2.28-to-3.0/","title":"Migrating from GeoServer Cloud 2.28.x to 3.0.0","text":"<p>This guide outlines the key configuration changes when upgrading from GeoServer Cloud 2.28.x to 3.0.0.</p> <p>Important Note: All configuration changes described in this document are already incorporated as the new defaults in each GeoServer Docker image's <code>/etc/geoserver</code> externalized configuration files. You only need to adjust these settings if you were using custom configurations that differ from the defaults.</p>"},{"location":"configuration/migration-2.28-to-3.0/#overview","title":"Overview","text":"<p>This is a major version upgrade with significant changes:</p> Component 2.28.x 3.0.0 Spring Boot 2.7.x 3.5.x GeoServer 2.28.x 3.0.x Java (minimum) 11 17+"},{"location":"configuration/migration-2.28-to-3.0/#breaking-changes","title":"Breaking Changes","text":""},{"location":"configuration/migration-2.28-to-3.0/#docker-compose-profile-configuration","title":"Docker Compose Profile Configuration","text":"<p>Breaking Change: The <code>config-first</code> profile is no longer included by default in the base service templates.</p> <p>If you are using the Spring Cloud Config Server (config-first bootstrap approach) with custom Docker Compose files, you must explicitly add the <code>config-first</code> profile:</p> <pre><code>services:\n  your-service:\n    environment:\n      SPRING_PROFILES_INCLUDE: config-first\n</code></pre> <p>This change affects all GeoServer microservices (wms, wfs, wcs, wps, gwc, restconfig, webui) and the gateway when using centralized configuration.</p> <p>Example from the documentation compose files:</p> <pre><code>x-variables:\n  environment: &amp;common_env\n    SPRING_PROFILES_INCLUDE: config-first\n    SPRING_PROFILES_ACTIVE: datadir\n    # ... other environment variables\n</code></pre>"},{"location":"configuration/migration-2.28-to-3.0/#removed-jdbc-config-backend","title":"Removed: JDBC Config Backend","text":"<p>The JDBC Config backend has been completely removed from GeoServer Cloud 3.0.0. If you are currently using the <code>jdbcconfig</code> profile, you must migrate to one of the supported backends:</p> <ul> <li>Data Directory (<code>datadir</code> profile): Traditional file-based configuration storage</li> <li>PostgreSQL (<code>pgconfig</code> profile): Database-backed configuration with full clustering support</li> </ul> <p>Migration path:</p> <ol> <li>Export your current configuration using the GeoServer REST API or Web UI</li> <li>Set up your new backend (datadir or pgconfig)</li> <li>Import the configuration into the new backend</li> <li>Update your Docker Compose or Kubernetes configuration to use the new profile</li> </ol>"},{"location":"configuration/migration-2.28-to-3.0/#configuration-property-changes","title":"Configuration Property Changes","text":""},{"location":"configuration/migration-2.28-to-3.0/#spring-cloud-gateway-properties","title":"Spring Cloud Gateway Properties","text":"<p>Spring Boot 3 includes a major upgrade to Spring Cloud Gateway. The gateway configuration namespace has changed:</p>"},{"location":"configuration/migration-2.28-to-3.0/#old-structure-228x","title":"Old Structure (2.28.x)","text":"<pre><code>spring:\n  cloud:\n    gateway:\n      routes:\n        - id: wms\n          uri: lb://wms-service\n          predicates:\n            - Path=/geoserver/wms/**\n</code></pre>"},{"location":"configuration/migration-2.28-to-3.0/#new-structure-300","title":"New Structure (3.0.0)","text":"<pre><code>spring:\n  cloud:\n    gateway:\n      server:\n        webflux:\n          routes:\n            - id: wms\n              uri: lb://wms-service\n              predicates:\n                - Path=/geoserver/wms/**\n</code></pre>"},{"location":"configuration/migration-2.28-to-3.0/#acl-client-configuration","title":"ACL Client Configuration","text":"<p>The GeoServer ACL client configuration property has been renamed for consistency:</p> Old Property (2.28.x) New Property (3.0.0) <code>geoserver.acl.enabled</code> <code>geoserver.acl.client.enabled</code> <p>Example:</p> <pre><code># Old (2.28.x)\ngeoserver:\n  acl:\n    enabled: true\n\n# New (3.0.0)\ngeoserver:\n  acl:\n    client:\n      enabled: true\n</code></pre>"},{"location":"configuration/migration-2.28-to-3.0/#http-client-migration","title":"HTTP Client Migration","text":"<p>GeoServer Cloud 3.0.0 has migrated from commons-httpclient to Apache HttpClient 5. If you have custom HTTP proxy configurations or custom HTTP client code, update your imports:</p> Old Package New Package <code>org.apache.commons.httpclient.*</code> <code>org.apache.hc.client5.http.*</code>"},{"location":"configuration/migration-2.28-to-3.0/#migration-steps","title":"Migration Steps","text":"<p>To migrate from GeoServer Cloud 2.28.x to 3.0.0:</p> <ol> <li> <p>Update Java Version: Ensure your deployment environment uses Java 17 or later.</p> </li> <li> <p>Add Config-First Profile (if using Spring Cloud Config Server): Add <code>SPRING_PROFILES_INCLUDE: config-first</code> to all GeoServer service environment variables in your Docker Compose or Kubernetes configuration.</p> </li> <li> <p>Migrate from JDBC Config (if applicable): Export your configuration and migrate to either <code>datadir</code> or <code>pgconfig</code> backend.</p> </li> <li> <p>Update Gateway Configurations (if customized): Move gateway route configurations from <code>spring.cloud.gateway</code> to <code>spring.cloud.gateway.server.webflux</code>.</p> </li> <li> <p>Update ACL Configuration (if customized): Rename <code>geoserver.acl.enabled</code> to <code>geoserver.acl.client.enabled</code>.</p> </li> <li> <p>Update HTTP Client Code (if customized): Migrate any custom HTTP client code from commons-httpclient to Apache HttpClient 5.</p> </li> <li> <p>Test Your Deployment: Verify all services start correctly and OWS endpoints respond as expected.</p> </li> </ol>"},{"location":"configuration/migration-2.28-to-3.0/#known-issues","title":"Known Issues","text":""},{"location":"configuration/migration-2.28-to-3.0/#rest-api-style-uploads","title":"REST API Style Uploads","text":"<p>REST API style uploads using path extensions (<code>.sld</code>, <code>.css</code>, etc.) may not work correctly due to Spring Boot 3 removing suffix pattern matching by default. This requires an upstream GeoServer fix.</p> <p>Workaround: Use the <code>Content-Type</code> header instead of file extensions when uploading styles via the REST API.</p>"},{"location":"configuration/migration-2.28-to-3.0/#developer-notes","title":"Developer Notes","text":"<p>For developers building custom extensions or running tests:</p>"},{"location":"configuration/migration-2.28-to-3.0/#test-framework-changes","title":"Test Framework Changes","text":"<p>Spring Boot 3 has deprecated <code>@MockBean</code> in favor of <code>@MockitoBean</code>:</p> <pre><code>// Old (2.28.x)\n@MockBean\nprivate SomeService someService;\n\n// New (3.0.0)\n@MockitoBean\nprivate SomeService someService;\n</code></pre>"},{"location":"configuration/migration-2.28-to-3.0/#additional-notes","title":"Additional Notes","text":"<ul> <li>The Docker images include all configuration changes by default in <code>/etc/geoserver</code></li> <li>Service names in gateway routes have been shortened for consistency</li> <li>All Spring Cloud dependencies have been upgraded to be compatible with Spring Boot 3.5</li> <li>If using custom externalized configuration files, review the geoserver-cloud-config repository for the complete set of changes</li> </ul>"},{"location":"deploy/","title":"Cloud Native GeoServer Deployment Guide","text":"<p>Docker images for all the services are available on DockerHub, under the geoservercloud organization.</p> <p>Starting with version <code>1.8.6</code>, all Docker images are signed with cosign.</p> <p>In order to verify the signatures, install cosign,download the cosign.pub file containing the public key, and run</p> <pre><code>cosign verify --key cosign.pub geoservercloud/&lt;image name&gt;:1.8.6\n</code></pre> <p>The public key can also be an environment variable. For example:</p> <pre><code>export GSC_COSIGN_PUB_KEY=`cat cosign.pub`\ncosign verify --key env://GSC_COSIGN_PUB_KEY geoservercloud/&lt;image name&gt;:1.8.6\n</code></pre> <p>In any case, replace <code>1.8.6</code> with the specific version you're using</p>"},{"location":"deploy/#available-docker-images","title":"Available Docker images","text":""},{"location":"deploy/#infrastructure","title":"Infrastructure","text":"<ul> <li>geoservercloud/geoserver-cloud-config: Spring Cloud Config server providing support for externalized configuration in a distributed system, as a central place to manage external properties for applications across all environments. <p>Usually you'd only use the config service in Docker Compose deployments. In a Kubernetes environment, we prefer to use the externalized configuration embedded in the Docker images under <code>/etc/geoserver/</code> and Kubernetes ConfigMaps or Secrets.</p> </li> <li>geoservercloud/geoserver-cloud-discovery: Netflix Eureka service registry for service discovery and client-side load balancing. <p>This service is primarily used in Docker Compose deployments. For Kubernetes deployments, it's recommended to use the <code>standalone</code> Spring profile and rely on Kubernetes Services for service discovery and load balancing.</p> </li> <li>geoservercloud/geoserver-cloud-gateway: Spring Cloud Gateway reverse proxy providing a single entry point to all GeoServer services.</li> </ul>"},{"location":"deploy/#geoserver-services","title":"GeoServer Services","text":"<ul> <li>geoservercloud/geoserver-cloud-wms GeoServer Web Map Server</li> <li>geoservercloud/geoserver-cloud-wfs GeoServer Web Feature Server</li> <li>geoservercloud/geoserver-cloud-wcs GeoServer Web Coverage Server</li> <li>geoservercloud/geoserver-cloud-wps GeoServer Web Processing Server</li> <li>geoservercloud/geoserver-cloud-gwc GeoServer GeoWebCache service</li> <li>geoservercloud/geoserver-cloud-rest GeoServer REST API service</li> <li>geoservercloud/geoserver-cloud-webui GeoServer configuration Web User Interface service</li> </ul>"},{"location":"deploy/#optional-security-services","title":"Optional security services","text":"<ul> <li>geoservercloud/geoserver-acl Access Control List service is an advanced authorization system for GeoServer.</li> </ul>"},{"location":"deploy/#test-onlynon-production-images","title":"Test-only/non-production images","text":"<ul> <li>geoservercloud/geoserver-cloud-admin-server: this is a simple spring-boot-admin image we use during development and it's not intended for production deployments.</li> </ul>"},{"location":"deploy/#docker-compose-deployments","title":"Docker compose deployments","text":"<p>Please check out the docker-compose deployment document.</p>"},{"location":"deploy/#kubernetes","title":"Kubernetes","text":"<p>Please check out the example Helm chart on this helm-geoserver-cloud repository as a starting point to deploy to K8s.</p>"},{"location":"deploy/docker-compose/","title":"GeoServer Cloud deployment with docker compose","text":"<p>GeoServer Cloud can be run in a docker composition.</p> <p>These instructions assume you have Docker Engine, Docker CLI, and the Compose Plugin installed.</p> <p>GeoServer Cloud can run with various GeoServer catalog and configuration storage backends. For scalability, we recommend using our PostgreSQL backend, <code>pgconfig</code>.</p> <p>Here are three <code>docker compose</code> based deployment examples to try out:</p> <ul> <li>Our preferred option, the pgconfig Catalog back-end, specifically developed for GeoServer Cloud with scalability in mind, storing all Catalog and GeoServer configuration in a PostgreSQL database.</li> <li>A shared data-directory option, using a mounted volume to share a traditional GeoServer data directory across all services.</li> </ul> <p>Open a terminal and enter the directory where you just downloaded that file, and run <code>docker compose pull</code> to fetch the docker images from Dockerhub:</p> <p>Note in order to run the containers as a non root user, all service definitions specify a <code>user: 1000:1000</code>, which you should change to the appropriate user id and group id especially if using bind volumes.</p> <pre><code>$ docker compose pull\nPulling rabbitmq  ... done\nPulling database  ... done\nPulling discovery ... done\nPulling config    ... done\nPulling gateway   ... done\nPulling wfs       ... done\nPulling wms       ... done\nPulling wcs       ... done\nPulling rest      ... done\nPulling gwc       ... done\nPulling webui     ... done\n</code></pre> <p>Then start the services with this command:</p> <pre><code>$ docker compose up -d\n</code></pre> <p>Wait for the services to start up, check with <code>docker compose ps</code> until they're healthy.</p> <p>Then browse to:</p> <ul> <li>http://localhost:8761 to access the Discovery service registry page.</li> <li>http://localhost:9090 for the GeoServer UI. The GateWay service    will take care of proxying requests to the appropriate microservice.</li> </ul> <p>From a usability point of view, there should be no appreciable differences with a traditional GeoServer deployment.</p> <p>What's going on inside the local-machine cluster you've just run is that each GeoServer business capability is running as a separate process in a separate docker container, and they're all in sync in a loosely coupled way using a message-driven event-bus.</p> <p>In this Docker Compose deployment, the following Spring Cloud components are used: - Eureka Discovery Service: Provides service discovery and client-side load balancing - Config Server: Centralizes configuration management - RabbitMQ: Enables event bus communication between services</p> <p>Experiment with dynamic service scaling and registration with <code>docker compose scale &lt;service&gt;=&lt;instances&gt;</code>, for example:</p> <pre><code>docker compose scale wfs=3 wcs=0\nStarting gscloud_wfs_1 ... done\nCreating gscloud_wfs_2 ... done\nCreating gscloud_wfs_3 ... done\nStopping and removing gscloud_wcs_1 ... done\n</code></pre> <p>Note for Kubernetes Deployments: For Kubernetes environments, it's recommended to use the <code>standalone</code> Spring profile instead of relying on Eureka and Config Server. Kubernetes provides native service discovery and load balancing through Kubernetes Services, and configuration can be managed through ConfigMaps or Secrets. This approach aligns better with Kubernetes architecture and provides more efficient scaling.</p>"},{"location":"deploy/helm/","title":"GeoServer Cloud deployment with Helm","text":"<p>This example demonstrates how to deploy a simple GeoserverCloud setup in your local cluster using Helm. It's a basic setup with the <code>pgconfig</code> profile enabled (catalog stored in a database). Based on the use of camptocamp/helm-geoserver-cloud chart.</p>"},{"location":"deploy/helm/#considerations","title":"Considerations","text":"<p>Make sure to review this documentation as a reference README.md . A local Kubernetes cluster and kubectl are required to run this demo.</p>"},{"location":"deploy/helm/#steps","title":"Steps","text":""},{"location":"deploy/helm/#1-update-dependencies","title":"1. Update dependencies","text":"<p>Before installing the chart, make sure Helm dependencies are up to date:</p> <pre><code>helm dependency update\n</code></pre>"},{"location":"deploy/helm/#2-install-chart","title":"2. Install chart","text":"<p>Now install (or upgrade) the chart in your cluster using the following command:</p> <pre><code>helm upgrade --install gs-cloud-pgconfig .\n</code></pre>"},{"location":"deploy/helm/#3-setup-alias","title":"3. Setup alias","text":"<p>To make it easier to access the services via a browser, we use the DNS name <code>gscloud.local</code>. You can map it to the local ingress IP by adding an entry to your <code>/etc/hosts</code> file:</p> <pre><code>kubectl get ingress --no-headers  gs-cloud-pgconfig-geoserver-host1 | awk '{printf(\"%s\\t%s\\n\",$4,$3 )}' | sudo tee -a /etc/hosts\n</code></pre>"},{"location":"deploy/helm/#4-check-pods-execution","title":"4. Check Pods execution","text":"<p>Verify that all necessary pods have started and are running correctly:</p> <pre><code>kubectl get po\n</code></pre> <p>Expected output: <pre><code>NAME                                            READY   STATUS    RESTARTS   AGE\ngs-cloud-pgconfig-gsc-gateway-87f5cf44c-bmcs5   1/1     Running   0          5m8s\ngs-cloud-pgconfig-gsc-gwc-79697d48d5-2bwlg      1/1     Running   0          5m8s\ngs-cloud-pgconfig-gsc-rest-bb4bb64c-jccdr       1/1     Running   0          5m8s\ngs-cloud-pgconfig-gsc-wcs-5df8b5bd69-bfwms      1/1     Running   0          5m8s\ngs-cloud-pgconfig-gsc-webui-84bb79b95f-zggkw    1/1     Running   0          5m8s\ngs-cloud-pgconfig-gsc-wfs-59df48668c-x4lw2      1/1     Running   0          5m8s\ngs-cloud-pgconfig-gsc-wms-d569fd94f-5vrmh       1/1     Running   0          5m8s\ngs-cloud-pgconfig-gsc-wps-94cbdd747-n69lf       1/1     Running   0          5m8s\ngs-cloud-pgconfig-postgresql-0                  1/1     Running   0          5m8s\ngs-cloud-pgconfig-rabbitmq-0                    1/1     Running   0          5m8s\n</code></pre></p>"},{"location":"deploy/helm/#5-initialize-example-catalog","title":"5. Initialize example catalog","text":"<p>Run the following script to populate the database with an initial catalog for testing:</p> <pre><code>./init-catalog.sh\n</code></pre>"},{"location":"deploy/helm/#6-access-webui","title":"6. Access WebUI","text":"<p>You can now access the GeoServer Cloud Web UI at: http://gscloud.local/geoserver-cloud/web/ Login with the default credentials: Username: <code>admin</code> Password: <code>geoserver</code></p>"},{"location":"deploy/helm/#uninstall-chart","title":"Uninstall chart","text":"<p>To clean up your cluster and remove the deployment:</p> <pre><code>helm uninstall gs-cloud-pgconfig\n</code></pre>"},{"location":"developer-guide/","title":"Developer's Guide","text":""},{"location":"developer-guide/#technology-overview","title":"Technology Overview","text":"<p>With GeoServer being a traditional, Spring Framework based, monolithic servlet application, a logical choice has been made to base the GeoServer derived microservices in the Spring Boot framework.</p> <p>Additionally, Spring Cloud technologies enable crucial capabilities such as dynamic service discovery, externalized configuration, distributed events, API gateway, and more.</p> <p>Only a curated list of the vast amount of GeoServer extensions will be supported, as they are verified and possibly adapted to work with this project's architecture.</p>"},{"location":"developer-guide/#system-architecture","title":"System Architecture","text":"<p>The following diagram depicts the System's general architecture:</p> <p></p> <ul> <li>Hexagons represent microservices;</li> <li>coloured rectangles, logical groupings of components;</li> <li>lines connecting a group to another component: connector applies to all services of the outgoing end, to all components of the incoming end; </li> <li>white rectangles, components that are platform/deployment choices. For example:<ul> <li>\"Event bus\" could be a cloud provider's native service (event queue), or a microservice implementing a distributed event broker;</li> <li>\"Catalog/Config backend\" is the software component used to access the catalog and configuration. Might be a microservice itself, catalog/config provider for  \"data  directory\", database, or other kind of external service store, catalog/config backend implementations;</li> <li>\"Catalog/Config storage\" is the storage mechanism that backs the catalog/config software component.  Might be a shared \"data  directory\" or database, a \"per instance\" data directory or database, and so on, depending on the available catalog/config backend implementations, and how they're configured and provisioned;</li> <li>\"Geospatial data sources\" is whatever method is used to access the actual data served up by the microservices.</li> </ul> </li> </ul> <p>Does that mean GeoServer's <code>.war</code> is deployed several times, with each instance exposing a given \"business capability\"? ABSOLUTELY NOT. Each microservice is its own self-contained application, including only the GeoServer dependencies it needs. Moreover, care has been taken so that when a dependency has both required and non-required components, only the required ones are loaded.</p> <p>Note the above diagram represents the overall system's architecture. This is not a deployment diagram. Deployment involves choice of platforms, configurations, and more; without affecting the general architecture. Some microservices/components, though planned and represented in the architecture diagram, have not yet been developed/integrated. For instance: the logging, tracing, and monitoring components, as well as the GWC and WPS microservices.</p>"},{"location":"developer-guide/#components-overview","title":"Components Overview","text":"<ul> <li>Front services:<ul> <li>Gateway</li> <li>Monitoring</li> </ul> </li> <li>Infrastructure:<ul> <li>Discovery</li> <li>Config</li> <li>Event bus</li> <li>Logging</li> <li>Tracing</li> <li>Cache</li> </ul> </li> <li>GeoServer:<ul> <li>Catalog</li> <li>OWS services</li> <li>REST API service</li> <li>Web-UI service</li> <li>GWC service</li> </ul> </li> </ul>"},{"location":"developer-guide/#project-source-code-structure","title":"Project source code structure","text":"<pre><code>        src/ ......................................... Project source code root directory\n        |_ apps ...................................... Root directory for microservice applications\n        |    |_ base-images/ ......................... Base Docker images for containerization\n        |    |     |_ geoserver/ ..................... Base image for GeoServer services\n        |    |     |_ jre/ ........................... Base JRE image\n        |    |     |_ spring-boot/ ................... Base Spring Boot image (Boot 2.x)\n        |    |\n        |    |_ infrastructure/ ...................... Infrastructure services\n        |    |     |_ config/ ........................ Spring-cloud config service\n        |    |     |_ discovery/...................... Spring-cloud discovery service\n        |    |     |_ gateway/ ....................... Spring-cloud gateway service\n        |    |\n        |    |_ geoserver/ ........................... Root directory for geoserver based microservices\n        |          |_ gwc/ ........................... GeoWebcache Service\n        |          |_ restconfig/ .................... GeoServer REST config API Service\n        |          |_ wcs/ ........................... Web Coverage Service\n        |          |_ webui/ ......................... GeoServer administration Web User Interface\n        |          |_ wfs/ ........................... Web Feature Service\n        |          |_ wms/ ........................... Web Map Service\n        |          |_ wps/ ........................... Web Processing Service\n        |\n        |_ catalog/ .................................. Root directory for GeoServer Catalog and Config libraries\n        |    |_ backends/ ............................ Spring Boot AutoConfigurations for specific catalog back-ends\n        |    |     |_ common/ ........................ Basic catalog and config bean wiring common to all back-ends\n        |    |     |_ datadir/ ....................... Shared \"data directory\" catalog back-end\n        |    |     |_ pgconfig/ ...................... PostgreSQL catalog back-end\n        |    |\n        |    |_ cache/ ............................... Spring Boot JCache support and auto-configurations for the Catalog\n        |    |_ events/ .............................. No-framework object model and runtime for catalog and config application events\n        |    |_ event-bus/ ........................... Integration layer for events with Spring Cloud Bus\n        |    |_ jackson-bindings/ .................... Libraries to encode and decode configuration objects as JSON\n        |    |     |_ geoserver/ ..................... Jackson bindings for GeoServer Catalog and Config object model\n        |    |     |_ geotools/ ...................... Jackson bindings for JTS Geometries and org.opengis.filter.Filter\n        |    |     |_ starter/ ....................... Spring Boot starter module to automate GeoTools and GeoServer Jackson bindings\n        |    |\n        |    |_ plugin/ .............................. Core Catalog and Config implementation and extensions\n        |\n        |_ extensions/ ............................... GeoServer Cloud extension modules \n        |    |_ app-schema/ .......................... Application Schema extension\n        |    |_ core/ ................................ Core extension module\n        |    |_ css-styling/ ......................... CSS Styling extension\n        |    |_ importer/ ............................ Importer extension\n        |    |_ mapbox-styling/ ...................... MapBox Styling extension\n        |    |_ input-formats/ ....................... Input format extensions\n        |    |     |_ raster-formats/ ................ Raster formats extensions\n        |    |     |_ vector-formats/ ................ Vector formats extensions\n        |    |\n        |    |_ ogcapi/ ............................... OGC API extensions\n        |    |     |_ features/ ...................... OGC API Features extension\n        |    |\n        |    |_ security/ ............................ Security extensions\n        |    |     |_ auth-key/ ...................... Auth Key security extension\n        |    |     |_ gateway-shared-auth/ ........... Gateway Shared Auth security extension\n        |    |     |_ geonode-oauth2/ ................ GeoNode OAuth2 security extension\n        |    |     |_ geoserver-acl/ ................. GeoServer ACL security extension\n        |    |     |_ jdbc/ .......................... JDBC security extension\n        |    |     |_ ldap/ .......................... LDAP security extension\n        |    |\n        |    |_ output-formats/ ....................... Output format extensions\n        |          |_ vector-tiles/ ................... Vector Tiles extension\n        |          |_ dxf/ ........................... DXF Vector format extension\n        |\n        |_ gwc ....................................... GeoWebCache modules\n        |    |_ autoconfigure/ ....................... Auto configurations for all GWC functionalities\n        |    |_ backends/ ............................ Integration of GWC storage backends (File, S3, Azure, etc.)\n        |    |     |_ pgconfig/ ...................... PostgreSQL GWC backend\n        |    |\n        |    |_ blobstores/ .......................... Blobstore implementations\n        |    |_ core/ ................................ Basic integration for GeoWebCache with GeoServer Cloud\n        |    |_ integration-bus/ ..................... Integration layer for GWC application events with Spring Cloud Bus\n        |    |_ services/ ............................ Support for GWC services integration (TMS, WMTS, etc.)\n        |    |_ starter/ ............................. Spring Boot starter for integrating GWC aspects with services\n        |\n        |_ library/ .................................. Common library modules\n        |    |_ spring-boot-simplejndi/ .............. Simple JNDI implementation for Spring Boot\n        |    |_ spring-factory/ ...................... Spring Factory utility\n        |\n        |_ starters .................................. Spring Boot starters for GeoServer microservices\n             |_ catalog-backend/ ..................... Groups all supported catalog back-ends\n             |_ input-formats/ ....................... Unified starter for all vector and raster input data formats\n             |_ event-bus/ ........................... Binds Spring Cloud Bus integration layer with a concrete event-bridge\n             |_ extensions/ .......................... Common extension functionality\n             |_ output-formats/ ....................... Output format extensions starter\n             |_ observability/ ....................... Observability support (Boot 2.x)\n             |_ observability-spring-boot-3/ ......... Observability support (Boot 3.x)\n             |_ security/ ............................ Security extensions and configurations\n             |_ spring-boot/ ......................... Basic Spring Boot integration (Boot 2.x)\n             |_ webmvc/ .............................. Spring Cloud and GeoServer integrations for web applications\n             |_ wms-extensions/ ...................... WMS extensions autoconfigurations\n</code></pre>"},{"location":"developer-guide/#building","title":"Building","text":"<p>Check out the build instructions document.</p>"},{"location":"developer-guide/#docker-images","title":"Docker Images","text":"<p>Learn about the Docker image architecture, including the base image hierarchy and layer sharing strategy that optimizes disk usage across all microservices.</p>"},{"location":"developer-guide/#logging","title":"Logging","text":"<p>Learn about logging configuration in GeoServer Cloud, including how logging bridges are configured and how GeoTools logging is integrated with Spring Boot's Logback.</p>"},{"location":"developer-guide/#coding-standards","title":"Coding Standards","text":"<p>GeoServer Cloud follows specific coding standards and style guidelines to ensure consistency across the project.</p>"},{"location":"developer-guide/#creating-extensions","title":"Creating Extensions","text":"<p>Learn how to create extensions for GeoServer Cloud.</p>"},{"location":"developer-guide/#running-for-development-and-testing","title":"Running for development and testing","text":"<p>The <code>./compose</code> folder contains docker-compose files intended only for development.</p> <p>For instructions on running GeoServer Cloud in your environment, follow the Quick Start guide on the user guide.</p>"},{"location":"developer-guide/#run-as-non-root","title":"Run as non-root","text":"<p>First thing first, edit the <code>.env</code> file to set the <code>GS_USER</code> variable to the user and group ids the applications should run as.</p> <p>Usually the GID and UID of your user, such as:</p> <pre><code>echo `id -g`:`id -u`\n1000:1000\n</code></pre>"},{"location":"developer-guide/#choose-your-catalog-and-configuration-back-end","title":"Choose your Catalog and Configuration back-end","text":"<p>You need to run <code>compose.yml</code> and pick one compose override file for a given GeoServer Catalog and Configuration back-end.</p>"},{"location":"developer-guide/#datadirectory-catalog-back-end","title":"DataDirectory Catalog back-end","text":"<p>The <code>datadir</code> spring boot profile enables the traditional \"data directory\" catalog back-end, with all GeoServer containers sharing the same directory. On a k8s deployment you would need a <code>ReadWriteMany</code> persistent volume.</p> <p>GeoServer-Cloud can start from an empty data directory.</p> <p>The <code>catalog-datadir.yml</code> docker compose override enables the <code>datadir</code> profile and initializes a volume with the default GeoServer release data directory.</p> <p>Run with:</p> <pre><code>$ docker compose -f compose.yml -f catalog-datadir.yml\n</code></pre> <p>or the more convenient shell script:</p> <pre><code>$ ./datadir up -d\n</code></pre>"},{"location":"developer-guide/#postgresql-catalog-back-end","title":"PostgreSQL Catalog back-end","text":"<p>The <code>pgconfig</code> spring boot profile enables the PostgreSQL catalog back-end.</p> <p>This is the preferred Catalog back-end for production deployments, and requires a PostgreSQL 15.0+ database</p> <p>The <code>catalog-pgconfig.yml</code> docker compose override enables the <code>pgconfig</code> profile and sets up a PostgreSQL container named <code>pgconfigdb</code>.</p> <p>On a production deployment, it is expected that the database is a provided service and not part of the GeoServer Cloud deployment.</p> <p>Run with:</p> <pre><code>$ docker compose -f compose.yml -f catalog-pgconfig.yml\n</code></pre> <p>Or the more convenient shell script:</p> <pre><code>$ ./pgconfig up -d\n</code></pre> <p>PGBouncer:</p> <p>Given the <code>pgconfig</code> catalog back-end will set up a database connection pool on each container, when scaling out you might run out of available connections in the Postgres server. A good way to avoid that and make better use of resources is to use a connection pooling service, such as pgbouncer.</p> <p>Use the <code>catalog-pgconfig.yml</code> in combination with the <code>pgbouncer.yml</code> docker compose override. <code>pgbouncer.yml</code> will override the three database containers with separate pgbouncer instances for each:</p> <ul> <li><code>pgconfigdb</code> becomes a <code>pgbouncer</code> container pointing to the <code>pgconfigdb_pg</code> container.</li> <li><code>acldb</code> becomes a <code>pgbouncer</code> container pointing to the <code>acldb_pg</code> container, and holds the GeoServer ACL database</li> <li><code>postgis</code> becomes a <code>pgbouncer</code> container pointing to the <code>postgis_pg</code> container.</li> </ul> <p>The <code>postgis</code> is container used to host sample data, it is not required but useful during development.</p>"},{"location":"developer-guide/#access-geoserver","title":"Access GeoServer","text":"<p>Verify the services are running with <code>docker compose ps</code> or <code>docker ps</code> as appropriate.</p> <pre><code>$ curl \"http://localhost:9090/geoserver/cloud/ows?request=getcapabilities&amp;service={WMS,WFS,WCS,WPS}\"\n$ curl -u admin:geoserver \"http://localhost:9090/geoserver/cloud/rest/workspaces.json\"\n</code></pre> <p>Browse to http://localhost:9090/geoserver/cloud/</p> <p>Note the <code>/geoserver/cloud</code> context path is set up in the <code>gateway-service</code>'s externalized configuration, and enforced through the <code>GEOSERVER_BASE_PATH</code> in <code>compose.yml</code>. You can change it to whatever you want. The default gateway-service.yml configuration file does not set up a context path at all, and hence GeoServer will be available at the root URL.</p>"},{"location":"developer-guide/#running-for-development","title":"Running for development","text":""},{"location":"developer-guide/#docker-compose","title":"docker-compose","text":"<p>Now run the docker composition as follows, the first time it might need to download some additional images for the <code>rabbitmq</code> event broker and the <code>postgresql</code> config database:</p> <pre><code>$ docker compose up -d\n</code></pre> <p>Run <code>docker compose logs -f</code> to watch startup progress of all services.</p> <p>Watch the output of <code>docker compose ps</code> until all services are healthy:</p> <pre><code>$ docker compose ps\n       Name                      Command                  State                   Ports                                                      \n-----------------------------------------------------------------------------------------------------------------\ngscloud_config_1      dockerize -wait http://dis ...   Up (healthy)                                                                                                                   \ngscloud_database_1    docker-entrypoint.sh postgres    Up (healthy)   0.0.0.0:5432-&gt;5432/tcp                                                                                          \ngscloud_discovery_1   /bin/sh -c exec java $JAVA ...   Up (healthy)   0.0.0.0:8761-&gt;8761/tcp                                                                                          \ngscloud_gateway_1     dockerize -wait http://con ...   Up (healthy)   0.0.0.0:9090-&gt;8080/tcp                                                                                          \ngscloud_rabbitmq_1    docker-entrypoint.sh rabbi ...   Up             15671/tcp, 0.0.0.0:15672-&gt;15672/tcp, ...\ngscloud_rest_1        dockerize -wait http://con ...   Up (healthy)                                                                                                                   \ngscloud_wcs_1         dockerize -wait http://con ...   Up (healthy)                                                                                                                   \ngscloud_webui_1       dockerize -wait http://con ...   Up (healthy)                                                                                                                   \ngscloud_wfs_1         dockerize --timeout 60s -w ...   Up (healthy)                                                                                                                   \ngscloud_wms_1         dockerize -wait http://con ...   Up (healthy)                     \n</code></pre> <p>Now you can access all front-services (<code>wms</code>, <code>wfs</code>, <code>wcs</code>, <code>rest</code>, and <code>webui</code>) through the <code>gateway</code> service at http://localhost:9090</p>"},{"location":"developer-guide/#running-a-service-in-developmentdebug-mode","title":"Running a service in development/debug mode","text":"<p>Running a single service in \"local\" mode (that is, outside the docker composition) can be done either through the command line or through the IDE.</p> <p>First, make sure at least the essential infrastructure services are running:</p> <pre><code>$ docker compose up -d discovery rabbitmq config database gateway\n</code></pre> <p>The <code>gateway</code> service is not essential, but useful to check it's correctly proxy'ing requests to your locally running services as well as the ones in the docker composition.</p> <p>To run a specific service through the command line, for example, <code>wfs-service</code>, run:</p> <pre><code>$ ./mvnw -f services/wfs spring-boot:run -Dspring-boot.run.profiles=local\n</code></pre> <p>To run a service through the IDE, execute the specific application class (for example, <code>org.geoserver.cloud.wfs.app.WfsApplication</code>), which is a regular Java class with a <code>main()</code> method, passing the JVM argument <code>-Dspring-boot.run.profiles=local</code>.</p> <p>The \"local\" spring profile in each <code>config/&lt;service&gt;.yml</code> file sets a different hard-coded port for each service, which aids in debugging a locally running service:</p> <ul> <li><code>wfs-service</code>: 9101</li> <li><code>wms-service</code>: 9102</li> <li><code>wcs-service</code>: 9103</li> <li><code>wps-service</code>: 9100</li> <li><code>restconfig-v1</code>: 9105</li> <li><code>web-ui</code>: 9106</li> </ul> <p>At startup time, as configured in its <code>src/main/resources/bootstrap.yml</code> file, the service will contact the <code>discovery-service</code> at the default <code>http://localhost:8761/eureka</code> location, given there's no <code>eureka.server.url</code> configuration property set (which is otherwise provided by <code>compose.yml</code>). Since <code>compose.yml</code> exposes the <code>discovery-service</code> at the local port <code>8761</code>, that's all the service being run locally needs to engage in the cluster. The discovery service will provide it with the location of any other service it needs to contact, starting with the <code>config-service</code>, where it will ultimatelly get the rest of the application configuration from.</p>"},{"location":"developer-guide/build_instructions/","title":"Building","text":""},{"location":"developer-guide/build_instructions/#geoserver-cloud-build-instructions","title":"GeoServer Cloud build instructions","text":"<p>Requirements:</p> <ul> <li>Java &gt;= 25 JDK</li> <li>Maven &gt;= <code>3.9.11</code> (included with the <code>mvnw</code> maven wrapper in the root folder)</li> <li>A recent Docker version with the Compose plugin.</li> </ul>"},{"location":"developer-guide/build_instructions/#clone-the-repository","title":"Clone the repository","text":"<p>Clone the repository, including submodules. Alternatively, replace the repository URL by your own fork's:</p> <pre><code>git clone --recurse-submodules git@github.com:geoserver/geoserver-cloud.git\n</code></pre> <p>The <code>--recurse-submodules</code> argument is necessary for <code>clone</code> to populate the <code>config/</code> directory from the geoserver/geoserver-cloud-config repository, which is in turn required to build the Docker images.</p> <p>If you already cloned the repository without it, initialize the submodule with</p> <pre><code>cd geoserver-cloud\ngit submodule update --init --recursive\n</code></pre>"},{"location":"developer-guide/build_instructions/#build","title":"Build","text":"<p>The <code>make</code> command from the project root directory will compile, test, and install all the project artifacts, and build the GeoServer-Cloud Docker images. So for a full build just run:</p> <pre><code>make\n</code></pre> <p>To build without running tests, run</p> <pre><code>make install\n</code></pre> <p>and run tests with</p> <pre><code>make test\n</code></pre> <p>finally clean the build with</p> <pre><code>make clean\n</code></pre>"},{"location":"developer-guide/build_instructions/#build-the-docker-images","title":"Build the docker images","text":"<p>As mentioned above, a <code>make</code> with no arguments will build everything.</p> <p>But to build only the docker images, run:</p> <pre><code>make build-image\n</code></pre> <p>This runs the <code>build-base-images</code>, <code>build-image-infrastructure</code>, and <code>build-image-geoserver</code> targets, which you can also run individually during development depending on your needs. Usually, you'd run <code>make build-image-geoserver</code> to speed up the process when made a change and want to test the geoserver containers, without having to rebuild the base and infra images.</p>"},{"location":"developer-guide/build_instructions/#multiplatform-amd64arm64-images","title":"Multiplatform (amd64/arm64) images","text":"<p>The \"build and push\" github actions job will create <code>linux/amd64</code> and <code>linux/arm64</code> multi-platform images by running</p> <pre><code>make build-image-multiplatform\n</code></pre> <p>This target assumes <code>buildx</code> is set up as an alias for <code>docker build</code> and there's a build runner that supports both platforms.</p> <p>Building multi-platform images requires pushing to the container registry, so the <code>build-image-multiplatform</code> target will run <code>docker compose build --push</code> with the appropriate <code>*-multiplatform.yml</code> compose file from the <code>docker-build</code> directory.</p> <p>If you want to build the multi-platform images yourself:</p> <ul> <li>Install QEmu</li> <li>Run the following command to create a <code>buildx</code> builder:</li> </ul> <pre><code>docker buildx create --name gscloud-builder --driver docker-container --bootstrap --use\n</code></pre> <p>In order to push the images to your own dockerhub account, use the <code>REPOSITORY</code> environment variable, for example:</p> <pre><code>REPOSITORY=groldan make build-image-multiplatform\n</code></pre> <p>will build and push <code>groldan/&lt;image-name&gt;:&lt;version&gt;</code> tagged images instead of the default <code>geoservercloud/&lt;image-name&gt;:&lt;version&gt;</code> ones.</p> <p>Finally, to remove the multi-platform builder, run</p> <pre><code>docker buildx stop gscloud-builder\ndocker buildx rm gscloud-builder\n</code></pre>"},{"location":"developer-guide/build_instructions/#note-on-custom-upstream-geoserver-version","title":"Note on custom upstream GeoServer version","text":"<p>GeoServer Cloud depends on a custom GeoServer branch, <code>gscloud/gs_version/integration</code>, which contains patches to upstream GeoServer that have not yet been integrated into the mainstream <code>main</code> branch.</p> <p>Additionally, this branch changes the artifact versions (e.g. from <code>2.28.0</code> to <code>2.28.0.0</code>), to avoid confusing maven if you also work with vanilla GeoServer, and to avoid your IDE downloading the latest <code>2.28-SNAPSHOT</code> artifacts from the OsGeo maven repository, overriding your local maven repository ones, and having confusing compilation errors that would require re-building the branch we need.</p> <p>The <code>gscloud/gs_version/integration</code> branch is checked out as a submodule on the camptocamp/geoserver-cloud-geoserver repository, which publishes the custom geoserver maven artifacts to the Github maven package registry.</p> <p>The root pom adds this additional maven repository, so no further action is required for the geoserver-cloud build to use those dependencies.</p>"},{"location":"developer-guide/coding_standards/","title":"Coding Standards and Style Guidelines","text":"<p>GeoServer Cloud follows a set of coding standards to ensure code consistency and quality across the project. This document outlines the key standards and how they are enforced.</p>"},{"location":"developer-guide/coding_standards/#introduction","title":"Introduction","text":"<p>Code style consistency is enforced using automated tools during the build process. The project uses a build-tools module approach, similar to other major Java projects like Apache Commons, Spring Framework, and Hibernate, to centralize style configuration.</p>"},{"location":"developer-guide/coding_standards/#checkstyle-configuration","title":"Checkstyle Configuration","text":"<p>Checkstyle is used to enforce consistent code style and formatting standards. The configuration is located in the <code>build-tools</code> module.</p>"},{"location":"developer-guide/coding_standards/#key-style-rules","title":"Key Style Rules","text":"<ul> <li>File Headers: All Java files must include the proper license header</li> <li>Import Control: Wildcard imports (e.g., <code>import java.util.*</code>) are forbidden to improve code readability</li> <li>Naming Conventions: Standard Java naming conventions are enforced</li> <li>Whitespace: Consistent tab and space usage is required</li> <li>Line Length: Lines should not exceed 120 characters</li> <li>Coding Practices: Various best practices are enforced, such as:</li> <li>Proper bracing</li> <li>Avoiding empty statements</li> <li>Implementing both <code>equals()</code> and <code>hashCode()</code></li> <li>Simplifying boolean expressions</li> </ul>"},{"location":"developer-guide/coding_standards/#configuration-files","title":"Configuration Files","text":"<p>The Checkstyle configuration is stored in the following files:</p> <ul> <li><code>build-tools/src/main/resources/checkstyle/checkstyle.xml</code>: Main configuration</li> <li><code>build-tools/src/main/resources/checkstyle/suppressions.xml</code>: Rules for suppressing certain checks</li> </ul>"},{"location":"developer-guide/coding_standards/#code-formatting","title":"Code Formatting","text":"<p>In addition to Checkstyle, the project uses:</p> <ul> <li>Spotless: For consistent Java code formatting using Palantir Java Format</li> <li>SortPOM: For consistent XML formatting in pom.xml files</li> </ul>"},{"location":"developer-guide/coding_standards/#running-style-checks","title":"Running Style Checks","text":"<p>Style checks are run as part of the build process. You can trigger them manually with:</p> <pre><code># Run all checks\nmake lint\n</code></pre> <p>or using maven directly:</p> <pre><code># Run all checks\nmvn validate -Dqa -fae -ntp -T1C\n\n# Run only Java formatting checks\nmvn validate -Dqa -fae -Dsortpom.skip=true -ntp -T1C\n\n# Run only POM checks\nmvn validate -Dqa -fae -Dspotless.skip=true -Dcheckstyle.skip=true -ntp -T1C\n</code></pre>"},{"location":"developer-guide/coding_standards/#fixing-style-issues","title":"Fixing Style Issues","text":"<p>To automatically fix style issues:</p> <pre><code># Format all files\nmake format\n\n# Format only Java files\nmake format-java\n\n# Format only POM files\nmake format-pom\n</code></pre>"},{"location":"developer-guide/coding_standards/#integration-with-ide","title":"Integration with IDE","text":"<p>Most common IDEs can be configured to follow these style guidelines:</p>"},{"location":"developer-guide/coding_standards/#intellij-idea","title":"IntelliJ IDEA","text":"<ul> <li>Install the Checkstyle-IDEA plugin</li> <li>Configure it to use the project's Checkstyle configuration</li> </ul>"},{"location":"developer-guide/coding_standards/#eclipse","title":"Eclipse","text":"<ul> <li>Install the Checkstyle plugin</li> <li>Configure it to use the project's Checkstyle configuration</li> </ul>"},{"location":"developer-guide/coding_standards/#vs-code","title":"VS Code","text":"<ul> <li>Install the Checkstyle for Java extension</li> <li>Configure it to use the project's Checkstyle configuration</li> </ul>"},{"location":"developer-guide/docker-images/","title":"Docker Images","text":"<p>This document explains the Docker image architecture in GeoServer Cloud, including the base image hierarchy and layer sharing strategy that optimizes disk usage and build times.</p>"},{"location":"developer-guide/docker-images/#base-image-hierarchy","title":"Base Image Hierarchy","text":"<p>GeoServer Cloud uses a layered base image strategy to maximize layer sharing across all microservices:</p> <pre><code>graph TD\n    A[eclipse-temurin:25-jre] --&gt; B[gs-cloud-base-jre]\n    B --&gt; C[gs-cloud-base-spring-boot]\n    C --&gt; D[gs-cloud-base-geoserver-image]\n    D --&gt; E[wfs]\n    D --&gt; F[wms]\n    D --&gt; G[wcs]\n    D --&gt; H[wps]\n    D --&gt; I[gwc]\n    D --&gt; J[rest]\n    D --&gt; K[webui]\n    B --&gt; L[config]\n    B --&gt; M[discovery]\n    B --&gt; N[gateway]</code></pre>"},{"location":"developer-guide/docker-images/#base-images","title":"Base Images","text":"Image Based On Adds <code>gs-cloud-base-jre</code> <code>eclipse-temurin:25-jre</code> JVM options (<code>--add-opens</code>, heap settings), system CA certificates <code>gs-cloud-base-spring-boot</code> <code>gs-cloud-base-jre</code> Spring Boot layered JAR structure, curl for health checks, default config <code>gs-cloud-base-geoserver-image</code> <code>gs-cloud-base-spring-boot</code> Fonts (DejaVu, Noto, Roboto, etc.), GeoServer common dependencies, DuckDB extensions"},{"location":"developer-guide/docker-images/#service-images","title":"Service Images","text":"<p>All GeoServer OWS services (WFS, WMS, WCS, WPS, GWC, REST, WebUI) extend <code>gs-cloud-base-geoserver-image</code>, adding only their service-specific application code.</p> <p>Infrastructure services (Config, Discovery, Gateway) extend <code>gs-cloud-base-spring-boot</code> directly since they don't need GeoServer dependencies.</p>"},{"location":"developer-guide/docker-images/#layer-sharing","title":"Layer Sharing","text":"<p>The layered architecture ensures that all GeoServer microservices share ~908MB of common layers. Each service adds only 2-22MB of unique application code.</p> <p>Example: GeoServer services layer analysis</p> Image Display Size Shared Unique wcs 909MB 907.8MB 1.7MB wps 910MB 907.8MB 2.3MB wfs 916MB 907.8MB 8.2MB rest 918MB 907.8MB 10.4MB wms 923MB 907.8MB 14.8MB gwc 922MB 907.8MB 14.2MB webui 929MB 907.8MB 21.5MB <p>Actual disk usage for all 7 GeoServer services:</p> <pre><code>907.8MB (shared once) + 73MB (sum of unique) = ~981MB\n</code></pre> <p>Instead of 7 \u00d7 920MB = 6.4GB apparent.</p> <p>This means deploying all 7 GeoServer services uses less than 1GB of actual disk space, not 6.4GB as the individual image sizes might suggest.</p>"},{"location":"developer-guide/docker-images/#analyzing-layer-sharing","title":"Analyzing Layer Sharing","text":""},{"location":"developer-guide/docker-images/#check-actual-disk-usage","title":"Check Actual Disk Usage","text":"<p>Use <code>docker system df -v</code> to see actual disk consumption with shared vs unique sizes:</p> <pre><code>docker system df -v | grep -A 50 \"REPOSITORY\"\n</code></pre> <p>Example output:</p> <pre><code>REPOSITORY                                     TAG              IMAGE ID       SIZE      SHARED SIZE   UNIQUE SIZE\ngeoservercloud/geoserver-cloud-wfs             3.0.0-SNAPSHOT   12cee949a17d   916MB     907.8MB       8.163MB\ngeoservercloud/geoserver-cloud-wms             3.0.0-SNAPSHOT   919b96914846   923MB     907.8MB       14.78MB\n...\n</code></pre>"},{"location":"developer-guide/docker-images/#compare-layers-across-images","title":"Compare Layers Across Images","text":"<p>To see which layers are shared across images:</p> <pre><code>for img in geoservercloud/geoserver-cloud-{wms,wfs,wcs,wps,gwc,webui,rest}:3.0.0-SNAPSHOT; do\n  echo \"=== $img ===\"\n  docker inspect \"$img\" --format='{{range .RootFS.Layers}}{{.}}{{\"\\n\"}}{{end}}'\ndone | sort | uniq -c | sort -rn\n</code></pre> <p>Layers appearing 7 times are shared across all services (the base image layers). Layers appearing once are unique to each service.</p>"},{"location":"developer-guide/docker-images/#count-total-vs-unique-layers","title":"Count Total vs Unique Layers","text":"<pre><code># Dump all layers\nfor img in $(docker images --format '{{.Repository}}:{{.Tag}}' | grep 3.0.0-SNAPSHOT); do\n  docker inspect \"$img\" --format='{{range .RootFS.Layers}}{{.}}{{\"\\n\"}}{{end}}'\ndone &gt; /tmp/all-layers.txt\n\n# Count\necho \"Total layer references: $(wc -l &lt; /tmp/all-layers.txt)\"\necho \"Unique layers: $(sort -u /tmp/all-layers.txt | wc -l)\"\n</code></pre>"},{"location":"developer-guide/docker-images/#best-practices","title":"Best Practices","text":"<ol> <li>Always build base images first - The Makefile enforces this with dependencies</li> <li>Don't skip base image rebuilds - When dependencies change, rebuild from <code>gs-cloud-base-geoserver-image</code> down</li> <li>Use <code>make build-image-geoserver &lt;service&gt;</code> - During development, rebuild only the service you're working on</li> <li>Check layer sharing periodically - Ensure changes don't accidentally break layer sharing</li> </ol>"},{"location":"developer-guide/logging/","title":"Logging","text":"<p>This document explains the logging architecture and implementation choices in GeoServer Cloud, including how logging dependencies are managed and how GeoTools/GeoServer logging is integrated with Spring Boot.</p>"},{"location":"developer-guide/logging/#logging-architecture-spring-jcl","title":"Logging Architecture: spring-jcl","text":"<p>GeoServer Cloud uses <code>spring-jcl</code> (Spring's Jakarta Commons Logging bridge) instead of the traditional <code>commons-logging</code> library. This is the recommended approach for Spring Boot applications.</p>"},{"location":"developer-guide/logging/#why-spring-jcl","title":"Why spring-jcl?","text":"<p>Spring Boot applications should use <code>spring-jcl</code> because:</p> <ol> <li>Spring Boot's default - Spring Boot automatically excludes <code>commons-logging</code> and provides <code>spring-jcl</code> as its replacement</li> <li>Seamless SLF4J integration - <code>spring-jcl</code> bridges directly to SLF4J/Logback without additional configuration</li> <li>No extra bridges needed - With <code>commons-logging</code>, you would need <code>jcl-over-slf4j</code> to route logs to Logback</li> <li>No classloader issues - The original <code>commons-logging</code> had notorious classloader discovery problems that <code>spring-jcl</code> eliminates</li> </ol>"},{"location":"developer-guide/logging/#the-upstream-geoserver-conflict","title":"The Upstream GeoServer Conflict","text":"<p>Upstream GeoServer's <code>gs-main</code> module explicitly excludes <code>spring-jcl</code>:</p> <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n  &lt;artifactId&gt;spring-core&lt;/artifactId&gt;\n  &lt;exclusions&gt;\n    &lt;exclusion&gt;\n      &lt;artifactId&gt;spring-jcl&lt;/artifactId&gt;\n      &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;/exclusion&gt;\n  &lt;/exclusions&gt;\n&lt;/dependency&gt;\n</code></pre> <p>This exclusion exists because traditional GeoServer (non-Spring Boot) uses <code>commons-logging</code> directly, and having both libraries causes <code>LogFactory</code> class conflicts.</p>"},{"location":"developer-guide/logging/#geoserver-cloud-solution","title":"GeoServer Cloud Solution","text":"<p>Since GeoServer Cloud is a Spring Boot application, we explicitly re-add <code>spring-jcl</code> in <code>src/apps/geoserver/pom.xml</code> to override the upstream exclusion. This ensures all GeoServer microservices use Spring Boot's preferred logging bridge.</p>"},{"location":"developer-guide/logging/#logging-initialization","title":"Logging Initialization","text":"<p>The logging bridge configuration is set up by <code>GeoServerContextInitializer</code> (<code>src/starters/webmvc/src/main/java/org/geoserver/cloud/autoconfigure/context/GeoServerContextInitializer.java</code>), which is an <code>ApplicationContextInitializer</code> that runs before Spring beans are loaded.</p> <p>This initializer replaces upstream GeoServer's <code>GeoserverInitStartupListener</code> (a servlet context listener that runs too late in Spring Boot) and configures the following system properties:</p> <pre><code>// Tell GeoServer not to control logging, Spring Boot will handle it\nSystem.setProperty(\"RELINQUISH_LOG4J_CONTROL\", \"true\");\n\n// Tell GeoTools to use Commons Logging for log redirection\nSystem.setProperty(\"GT2_LOGGING_REDIRECTION\", \"CommonsLogging\");\n</code></pre> <p>The <code>GT2_LOGGING_REDIRECTION=CommonsLogging</code> setting is crucial because:</p> <ol> <li>It configures GeoTools to redirect its <code>java.util.logging</code> calls through Commons Logging</li> <li>Commons Logging calls are then handled by <code>spring-jcl</code></li> <li><code>spring-jcl</code> bridges to SLF4J</li> <li>SLF4J routes to Logback (Spring Boot's default)</li> </ol> <p>This creates the logging chain: GeoTools JUL -&gt; Commons Logging -&gt; spring-jcl -&gt; SLF4J -&gt; Logback</p> <p>Other redirection options were considered but rejected: - Logback: Incorrectly maps logging levels (e.g., FINE called with INFO doesn't log) - Log4J2: Fails when calling <code>Logger.setLevel()</code> due to API changes in newer Log4j2 versions</p>"},{"location":"developer-guide/event-bus/","title":"Understanding the event bus data flow","text":"<p>For general information about the event bus, have a look here.</p> <p>The following diagram demonstrates the data flow on the event bus:</p> <p></p> <ol> <li>Changes on the catalog/config level are usually done via the REST interface or the WebUI (via the Gateway)</li> <li>Changes are persisted in the catalog/config</li> <li>The <code>CatalogApplicationEventPublisher</code> listens to the events of the (native) GeoServer/Catalog (triggered by step 2)</li> <li>Whenever such an event fires, the <code>CatalogApplicationEventPublisher</code> will publish a \"local\" <code>GeoServerEvent</code>. Have a look here for the full type hierarchy.</li> <li>The <code>RemoteGeoServerEventBridge</code> (listens to these <code>GeoServerEvent</code>s and) broadcasts <code>RemoteGeoServerEvent</code>s to the event bus.</li> <li>All registered microservices listen for incoming <code>RemoteGeoServerEvent</code>s</li> <li>The payload of these remote events will be published as local events to reload/refresh the catalog/config locally.</li> </ol>"},{"location":"developer-guide/extensions/adding_extensions/","title":"Adding Extensions to GeoServer Cloud","text":"<p>This guide outlines the process for adding new extensions to the GeoServer Cloud ecosystem. Extensions allow for modularity and flexibility in the codebase, enabling features to be optionally included based on application requirements.</p>"},{"location":"developer-guide/extensions/adding_extensions/#extension-architecture","title":"Extension Architecture","text":"<p>GeoServer Cloud organizes extensions in a modular structure:</p> <ol> <li>Extension Module - The core implementation</li> <li>Located in <code>src/extensions/&lt;category&gt;/&lt;extension-name&gt;</code></li> <li>Contains auto-configuration, properties, and conditional annotations</li> <li> <p>Self-contained with clear dependencies</p> </li> <li> <p>Starter Module - The convenient inclusion mechanism</p> </li> <li>Located in <code>src/starters/&lt;category&gt;</code></li> <li>Depends on relevant extension modules</li> <li>Provides a single dependency for users to include</li> </ol>"},{"location":"developer-guide/extensions/adding_extensions/#step-by-step-guide","title":"Step-by-Step Guide","text":""},{"location":"developer-guide/extensions/adding_extensions/#1-create-the-extension-module-structure","title":"1. Create the Extension Module Structure","text":"<p>First, create the appropriate directory structure for your extension:</p> <pre><code>src/extensions/\n  \u2514\u2500\u2500 &lt;category&gt;/\n      \u2514\u2500\u2500 &lt;extension-name&gt;/\n          \u251c\u2500\u2500 pom.xml\n          \u2514\u2500\u2500 src/\n              \u251c\u2500\u2500 main/\n              \u2502   \u251c\u2500\u2500 java/\n              \u2502   \u2502   \u2514\u2500\u2500 org/geoserver/cloud/autoconfigure/extensions/...\n              \u2502   \u2514\u2500\u2500 resources/\n              \u2502       \u2514\u2500\u2500 META-INF/\n              \u2502           \u2514\u2500\u2500 spring.factories (or spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports)\n              \u2514\u2500\u2500 test/\n                  \u251c\u2500\u2500 java/\n                  \u2502   \u2514\u2500\u2500 org/geoserver/cloud/autoconfigure/extensions/...\n                  \u2514\u2500\u2500 resources/\n</code></pre> <p>Where: - <code>&lt;category&gt;</code> is the functional category (e.g., <code>security</code>, <code>input-formats</code>, <code>output-formats</code>, etc.) - <code>&lt;extension-name&gt;</code> is the specific extension name</p>"},{"location":"developer-guide/extensions/adding_extensions/#2-configure-the-module-pom","title":"2. Configure the Module POM","text":"<p>Create a <code>pom.xml</code> file for your extension with the appropriate dependencies:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n  &lt;parent&gt;\n    &lt;groupId&gt;org.geoserver.cloud.extensions&lt;/groupId&gt;\n    &lt;artifactId&gt;gs-cloud-extensions-&lt;category&gt;&lt;/artifactId&gt;\n    &lt;version&gt;${revision}&lt;/version&gt;\n  &lt;/parent&gt;\n  &lt;artifactId&gt;gs-cloud-extension-&lt;category&gt;-&lt;extension-name&gt;&lt;/artifactId&gt;\n  &lt;packaging&gt;jar&lt;/packaging&gt;\n  &lt;description&gt;GeoServer Cloud &lt;extension-name&gt; extension&lt;/description&gt;\n\n  &lt;dependencies&gt;\n    &lt;!-- Core extension dependency --&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.geoserver.cloud.extensions&lt;/groupId&gt;\n      &lt;artifactId&gt;gs-cloud-extensions-core&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n\n    &lt;!-- Extension-specific dependencies --&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.geoserver&lt;/groupId&gt;\n      &lt;artifactId&gt;gs-&lt;extension-related-module&gt;&lt;/artifactId&gt;\n      &lt;optional&gt;true&lt;/optional&gt;\n    &lt;/dependency&gt;\n\n    &lt;!-- Required for Spring Boot auto-configuration metadata generation --&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n      &lt;artifactId&gt;spring-boot-autoconfigure-processor&lt;/artifactId&gt;\n      &lt;optional&gt;true&lt;/optional&gt;\n    &lt;/dependency&gt;\n\n    &lt;!-- Test dependencies are inherited from parent --&gt;\n  &lt;/dependencies&gt;\n\n  &lt;build&gt;\n    &lt;plugins&gt;\n      &lt;!-- Required: configure annotation processors for auto-configuration metadata --&gt;\n      &lt;plugin&gt;\n        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n        &lt;configuration&gt;\n          &lt;annotationProcessorPaths&gt;\n            &lt;path&gt;\n              &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n              &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n              &lt;version&gt;${lombok.version}&lt;/version&gt;\n            &lt;/path&gt;\n            &lt;path&gt;\n              &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n              &lt;artifactId&gt;spring-boot-autoconfigure-processor&lt;/artifactId&gt;\n            &lt;/path&gt;\n          &lt;/annotationProcessorPaths&gt;\n        &lt;/configuration&gt;\n      &lt;/plugin&gt;\n    &lt;/plugins&gt;\n  &lt;/build&gt;\n&lt;/project&gt;\n</code></pre> <p>Important: The <code>spring-boot-autoconfigure-processor</code> dependency and its corresponding <code>annotationProcessorPaths</code> entry in <code>maven-compiler-plugin</code> are required for all modules with auto-configurations. This generates <code>META-INF/spring-autoconfigure-metadata.properties</code> at compile time, enabling Spring Boot to filter auto-configuration classes efficiently without loading them.</p>"},{"location":"developer-guide/extensions/adding_extensions/#3-add-the-extension-to-the-parent-pom","title":"3. Add the Extension to the Parent POM","text":"<p>Add your extension module to its category's parent <code>pom.xml</code>. For example, if adding a security extension, update:</p> <pre><code>&lt;!-- In src/extensions/security/pom.xml --&gt;\n&lt;modules&gt;\n  &lt;!-- existing modules --&gt;\n  &lt;module&gt;&lt;extension-name&gt;&lt;/module&gt;\n&lt;/modules&gt;\n</code></pre>"},{"location":"developer-guide/extensions/adding_extensions/#4-add-the-extension-to-the-dependency-management-section","title":"4. Add the Extension to the Dependency Management Section","text":"<p>Add your extension to the dependency management section in the root <code>pom.xml</code>:</p> <pre><code>&lt;dependencyManagement&gt;\n  &lt;dependencies&gt;\n    &lt;!-- existing dependencies --&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.geoserver.cloud.extensions&lt;/groupId&gt;\n      &lt;artifactId&gt;gs-cloud-extension-&lt;category&gt;-&lt;extension-name&gt;&lt;/artifactId&gt;\n      &lt;version&gt;${project.version}&lt;/version&gt;\n    &lt;/dependency&gt;\n  &lt;/dependencies&gt;\n&lt;/dependencyManagement&gt;\n</code></pre>"},{"location":"developer-guide/extensions/adding_extensions/#5-create-configuration-properties","title":"5. Create Configuration Properties","text":"<p>Create a configuration properties class to enable/disable and configure your extension:</p> <pre><code>package org.geoserver.cloud.autoconfigure.extensions.&lt;category&gt;.&lt;extensionname&gt;;\n\nimport lombok.Data;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\n\n@Data\n@ConfigurationProperties(prefix = &lt;Extension&gt;ConfigProperties.PREFIX)\npublic class &lt;Extension&gt;ConfigProperties {\n\n    public static final String PREFIX = \"geoserver.extension.&lt;category&gt;.&lt;extension-name&gt;\";\n\n    /** Whether the extension is enabled (default: false) */\n    public static final boolean DEFAULT = false;\n\n    /** Enable/disable the extension */\n    private boolean enabled = DEFAULT;\n\n    /** Additional configuration properties */\n    private String someProperty;\n}\n</code></pre>"},{"location":"developer-guide/extensions/adding_extensions/#6-create-a-conditional-annotation","title":"6. Create a Conditional Annotation","text":"<p>Create a custom conditional annotation to control when your extension's beans are registered:</p> <pre><code>package org.geoserver.cloud.autoconfigure.extensions.&lt;category&gt;.&lt;extensionname&gt;;\n\nimport java.lang.annotation.*;\nimport org.geoserver.cloud.autoconfigure.extensions.ConditionalOnGeoServer;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Documented\n@Inherited\n@ConditionalOnGeoServer\n@ConditionalOnProperty(\n        prefix = &lt;Extension&gt;ConfigProperties.PREFIX,\n        name = \"enabled\",\n        havingValue = \"true\",\n        matchIfMissing = &lt;Extension&gt;ConfigProperties.DEFAULT)\npublic @interface ConditionalOn&lt;Extension&gt; {}\n</code></pre>"},{"location":"developer-guide/extensions/adding_extensions/#7-create-auto-configuration-class","title":"7. Create Auto-Configuration Class","text":"<p>Create an auto-configuration class for your extension:</p> <pre><code>package org.geoserver.cloud.autoconfigure.extensions.&lt;category&gt;.&lt;extensionname&gt;;\n\nimport javax.annotation.PostConstruct;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.boot.autoconfigure.AutoConfiguration;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\n\n@AutoConfiguration\n@EnableConfigurationProperties(&lt;Extension&gt;ConfigProperties.class)\n@ConditionalOn&lt;Extension&gt;\n@Slf4j(topic = \"org.geoserver.cloud.autoconfigure.extensions.&lt;category&gt;.&lt;extensionname&gt;\")\npublic class &lt;Extension&gt;AutoConfiguration {\n\n    private final &lt;Extension&gt;ConfigProperties properties;\n\n    public &lt;Extension&gt;AutoConfiguration(&lt;Extension&gt;ConfigProperties properties) {\n        this.properties = properties;\n    }\n\n    @PostConstruct\n    void log() {\n        log.info(\"GeoServer &lt;Extension&gt; extension enabled\");\n    }\n\n    @Bean\n    public SomeExtensionBean someExtensionBean() {\n        return new SomeExtensionBean(properties.getSomeProperty());\n    }\n}\n</code></pre>"},{"location":"developer-guide/extensions/adding_extensions/#8-register-auto-configuration","title":"8. Register Auto-Configuration","text":"<p>Depending on your Spring Boot version:</p> <p>For Spring Boot 2.x, add to <code>META-INF/spring.factories</code>: <pre><code>org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.geoserver.cloud.autoconfigure.extensions.&lt;category&gt;.&lt;extensionname&gt;.&lt;Extension&gt;AutoConfiguration\n</code></pre></p> <p>For Spring Boot 3.x, add to <code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>: <pre><code>org.geoserver.cloud.autoconfigure.extensions.&lt;category&gt;.&lt;extensionname&gt;.&lt;Extension&gt;AutoConfiguration\n</code></pre></p>"},{"location":"developer-guide/extensions/adding_extensions/#9-write-tests","title":"9. Write Tests","text":"<p>Create tests to verify your extension:</p> <pre><code>package org.geoserver.cloud.autoconfigure.extensions.&lt;category&gt;.&lt;extensionname&gt;;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.mockito.Mockito.mock;\n\nimport org.geoserver.config.GeoServer;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.autoconfigure.AutoConfigurations;\nimport org.springframework.boot.test.context.FilteredClassLoader;\nimport org.springframework.boot.test.context.runner.ApplicationContextRunner;\n\nclass &lt;Extension&gt;AutoConfigurationTest {\n\n    // Create a common test method to verify conditional activation\n    private void verifyConditionalActivation(\n            ApplicationContextRunner runner,\n            String propertyName,\n            Class&lt;?&gt; componentClass) {\n\n        // Test without the property set - condition should not activate\n        runner.run(context -&gt; {\n            assertThat(context).doesNotHaveBean(componentClass);\n        });\n\n        // Test with the property set to false - condition should not activate\n        runner\n                .withPropertyValues(propertyName + \"=false\")\n                .run(context -&gt; {\n                    assertThat(context).doesNotHaveBean(componentClass);\n                });\n\n        // Test with the property set to true - condition should activate\n        runner\n                .withPropertyValues(propertyName + \"=true\")\n                .run(context -&gt; {\n                    assertThat(context).hasSingleBean(componentClass);\n                });\n    }\n\n    @Test\n    void testDisabledByDefault() {\n        var contextRunner = new ApplicationContextRunner()\n                .withBean(\"geoServer\", GeoServer.class, () -&gt; mock(GeoServer.class))\n                .withConfiguration(AutoConfigurations.of(&lt;Extension&gt;AutoConfiguration.class));\n\n        contextRunner.run(context -&gt; {\n            assertThat(context).hasNotFailed();\n            assertThat(context).doesNotHaveBean(&lt;Extension&gt;AutoConfiguration.class);\n            assertThat(context).getBean(&lt;Extension&gt;ConfigProperties.class)\n                    .hasFieldOrPropertyWithValue(\"enabled\", false);\n        });\n    }\n\n    @Test\n    void testConditionalActivation() {\n        var contextRunner = new ApplicationContextRunner()\n                .withBean(\"geoServer\", GeoServer.class, () -&gt; mock(GeoServer.class))\n                .withConfiguration(AutoConfigurations.of(&lt;Extension&gt;AutoConfiguration.class));\n\n        verifyConditionalActivation(\n                contextRunner,\n                \"geoserver.extension.&lt;category&gt;.&lt;extension-name&gt;.enabled\",\n                &lt;Extension&gt;AutoConfiguration.class);\n    }\n\n    @Test\n    void testClassCondition() {\n        // Test with required class filtered out\n        new ApplicationContextRunner()\n                .withClassLoader(new FilteredClassLoader(RequiredClass.class))\n                .withBean(\"geoServer\", GeoServer.class, () -&gt; mock(GeoServer.class))\n                .withPropertyValues(\"geoserver.extension.&lt;category&gt;.&lt;extension-name&gt;.enabled=true\")\n                .withConfiguration(AutoConfigurations.of(&lt;Extension&gt;AutoConfiguration.class))\n                .run(context -&gt; {\n                    // Even with the property set to true, bean should not be created\n                    // when the required class is not available\n                    assertThat(context).doesNotHaveBean(&lt;Extension&gt;AutoConfiguration.class);\n                });\n    }\n}\n</code></pre>"},{"location":"developer-guide/extensions/adding_extensions/#10-add-to-the-starter-module","title":"10. Add to the Starter Module","text":"<p>Add your extension to the appropriate starter:</p> <pre><code>&lt;!-- In src/starters/&lt;category&gt;/pom.xml --&gt;\n&lt;dependencies&gt;\n  &lt;!-- existing dependencies --&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;org.geoserver.cloud.extensions&lt;/groupId&gt;\n    &lt;artifactId&gt;gs-cloud-extension-&lt;category&gt;-&lt;extension-name&gt;&lt;/artifactId&gt;\n  &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>"},{"location":"developer-guide/extensions/adding_extensions/#11-add-configuration-to-geoserveryml","title":"11. Add Configuration to <code>geoserver.yml</code>","text":"<p>Add your extension's configuration to <code>config/geoserver.yml</code>:</p> <pre><code>geoserver:\n  extension:\n    &lt;category&gt;:\n      &lt;extension-name&gt;:\n        enabled: ${geoserver.&lt;extension-name&gt;.enabled:false}\n        # Other properties\n</code></pre>"},{"location":"developer-guide/extensions/adding_extensions/#12-create-documentation","title":"12. Create Documentation","text":"<p>Create a README.md file with documentation for your extension:</p> <pre><code># GeoServer &lt;Extension&gt; Extension\n\nThis module integrates &lt;extension functionality&gt; with GeoServer Cloud.\n\n## Overview\n\n&lt;Overview of what the extension does&gt;\n\n## Configuration\n\nThe extension is **disabled by default**. To enable it, add the following configuration:\n\n```yaml\ngeoserver:\n  extension:\n    &lt;category&gt;:\n      &lt;extension-name&gt;:\n        enabled: true\n</code></pre>"},{"location":"developer-guide/extensions/adding_extensions/#implementation-details","title":"Implementation Details","text":""},{"location":"developer-guide/extensions/adding_extensions/#real-world-examples","title":"Real-World Examples","text":""},{"location":"developer-guide/extensions/adding_extensions/#example-adding-a-security-extension","title":"Example: Adding a Security Extension","text":"<p>Here's a simplified example from adding the GeoServer ACL security extension:</p> <ol> <li>Directory Structure:</li> </ol> <pre><code>src/extensions/security/geoserver-acl/\n</code></pre> <ol> <li>Configuration Properties:</li> </ol> <pre><code>@Data\n@ConfigurationProperties(prefix = AclConfigProperties.PREFIX)\npublic class AclConfigProperties {\n    public static final String PREFIX = \"geoserver.extension.security.acl\";\n    public static final String LEGACY_PREFIX = \"geoserver.acl\";\n    public static final boolean DEFAULT = false;\n    private boolean enabled = DEFAULT;\n}\n</code></pre> <ol> <li>Conditional Annotation:</li> </ol> <pre><code>@ConditionalOnGeoServer\n@ConditionalOnProperty(\n        prefix = AclConfigProperties.PREFIX,\n        name = \"enabled\",\n        havingValue = \"true\",\n        matchIfMissing = AclConfigProperties.DEFAULT)\npublic @interface ConditionalOnAcl {}\n</code></pre> <ol> <li>Auto-Configuration:</li> </ol> <pre><code>@AutoConfiguration\n@EnableConfigurationProperties(AclConfigProperties.class)\n@ConditionalOnAcl\npublic class AclAutoConfiguration {\n    @PostConstruct\n    void log() {\n        log.info(\"GeoServer ACL extension enabled\");\n    }\n}\n</code></pre>"},{"location":"developer-guide/extensions/adding_extensions/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Clear Dependencies: Make dependencies explicit and use <code>&lt;optional&gt;true&lt;/optional&gt;</code> for those that might not be available.</p> </li> <li> <p>Consistent Naming: Follow naming conventions used by existing extensions.</p> </li> <li> <p>Default to Disabled: Extensions should be disabled by default (<code>DEFAULT = false</code>).</p> </li> <li> <p>Test Coverage: Write comprehensive tests using <code>ApplicationContextRunner</code>.</p> </li> <li> <p>Mock Dependencies: Use Mockito to mock any beans required by the conditional annotations.</p> </li> <li> <p>Documentation: Provide clear documentation for your extension.</p> </li> <li> <p>Configuration Properties: Use standard prefixes and provide both new and legacy property support when needed.</p> </li> <li> <p>Handling Service-Specific Extensions: For extensions that require specific GeoServer services (like WMS), use additional conditional annotations like <code>@ConditionalOnGeoServerWMS</code>.</p> </li> </ol> <p>By following these guidelines, you can create well-structured, testable, and maintainable extensions for GeoServer Cloud.</p>"},{"location":"developer-guide/extensions/adding_extensions/#advanced-concepts","title":"Advanced Concepts","text":""},{"location":"developer-guide/extensions/adding_extensions/#service-specific-extensions","title":"Service-Specific Extensions","text":"<p>For extensions that should only be active when a specific GeoServer service is available (like WMS, WFS, etc.), utilize the service-specific conditional annotations:</p> <pre><code>import org.geoserver.cloud.autoconfigure.extensions.ConditionalOnGeoServerWMS;\n\n@Configuration\n@ConditionalOnGeoServerWMS\npublic class WmsSpecificExtensionConfiguration {\n    // Beans that only make sense in a WMS service\n}\n</code></pre> <p>These conditionals check for: 1. The required service class on the classpath 2. A service-specific property being enabled (e.g., <code>geoserver.service.wms.enabled=true</code>)</p> <p>The service properties are automatically set to <code>true</code> in each service's bootstrap configuration file, making service detection reliable without requiring explicit bean activation checks.</p> <p>Available service conditionals: - <code>@ConditionalOnGeoServerWMS</code> - For WMS service extensions - <code>@ConditionalOnGeoServerWFS</code> - For WFS service extensions - <code>@ConditionalOnGeoServerWCS</code> - For WCS service extensions - <code>@ConditionalOnGeoServerWPS</code> - For WPS service extensions - <code>@ConditionalOnGeoServerREST</code> - For REST Configuration service extensions - <code>@ConditionalOnGeoServerWebUI</code> - For Web UI extensions</p>"},{"location":"developer-guide/extensions/adding_extensions/#integration-with-ui-components","title":"Integration with UI Components","text":"<p>For extensions that integrate with the GeoServer web UI:</p> <ol> <li>Add resources to <code>src/main/resources/org/geoserver/...</code></li> <li>Implement UI beans (like <code>LoginFormInfo</code>) with appropriate priorities</li> <li>Use the <code>org.geoserver.web</code> package structure</li> <li>Use <code>@ConditionalOnGeoServerWebUI</code> to ensure it only activates in the web UI service</li> </ol>"},{"location":"developer-guide/extensions/adding_extensions/#extension-priority","title":"Extension Priority","text":"<p>When multiple extensions provide similar functionality, use the <code>ExtensionPriority</code> interface:</p> <pre><code>public class PrioritizableComponent implements ExtensionPriority {\n    private int priority = ExtensionPriority.LOWEST;\n\n    @Override\n    public int getPriority() {\n        return priority;\n    }\n\n    public void setPriority(int priority) {\n        this.priority = priority;\n    }\n}\n</code></pre>"},{"location":"developer-guide/extensions/adding_extensions/#backward-compatibility","title":"Backward Compatibility","text":"<p>For maintaining backward compatibility with existing configurations:</p> <ol> <li>Support both new and legacy property prefixes</li> <li>Use property placeholders in <code>geoserver.yml</code>:    <pre><code>geoserver:\n  extension:\n    category:\n      name:\n        enabled: ${legacy.property.name:false}\n</code></pre></li> </ol>"},{"location":"developer-guide/extensions/adding_extensions/#conclusion","title":"Conclusion","text":"<p>Creating well-structured extensions for GeoServer Cloud promotes maintainability, testability, and modularity. By following this guide, you can create extensions that seamlessly integrate with the GeoServer Cloud ecosystem while maintaining high code quality standards.</p>"},{"location":"developer-guide/services/discovery-service/","title":"Cloud Native GeoServer Discovery service","text":"<p>The Discovery Service maintains a registry of the location and health status of other services.</p> <p>Any other service participating in the cluster will register to the Discovery Service at start up, and de-register at graceful shut down time.</p> <p>Inter-service communication will then be automatically load balanced to all available service instances of a given type.</p> <p>The most common scenario is when for High Availability or performance reasons, there are several instances of a specific service, hence incoming requests passing through the [Gateway Service] get served by a different instance in a round-robin fashion.</p> <p>Docker image: <code>geoservercloud/gs-cloud-discovery-service</code>. </p> <p>Service name: <code>discovery-service</code>. </p> <p>This is the logical service name.  Since we're using a \"discovery first bootstrap\"  approach to service orchestration, other services won't use this service name to locate the discovery service, but a fixed list of service addresses need to be provided. See the \"Client Configuration\" section below for more details.</p>"},{"location":"developer-guide/services/discovery-service/#reference-documentation","title":"Reference documentation","text":"<ul> <li>Spring Cloud Netflix reference</li> <li>Discovery First Bootstrap Config Client</li> </ul>"},{"location":"developer-guide/services/discovery-service/#service-configuration","title":"Service Configuration","text":""},{"location":"developer-guide/services/discovery-service/#client-configuration","title":"Client Configuration","text":""},{"location":"developer-guide/services/discovery-service/#developing","title":"Developing","text":"<p>In the default docker composition, there's only one instance of the discovery service. In a High Availability deployment scenario, more instances can be launched, al</p> <p>Since the discovery service are fixed entry points, we're setting up two peer aware eureka instances for HA.</p> <p>Browse to http://localhost:8761 and http://localhost:8762 to verify they see each other and all services are registered at both eureka instances.</p> <p>See http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_peer_awareness</p> <p>https://docs.spring.io/spring-cloud-netflix/docs/2.2.7.RELEASE/reference/html/</p>"},{"location":"developer-guide/services/gateway-service/","title":"Cloud Native GeoServer Gateway service","text":"<p>Docker image: <code>geoservercloud/gs-cloud-gateway</code>. </p> <p>Service name: <code>gateway-service</code>. </p> <p>This is the logical service name by which web clients will get the actual instances addresses from the [discovery-service] and perform client-side load balancing against when interacting with the service.</p>"},{"location":"developer-guide/services/gateway-service/#service-configuration","title":"Service Configuration","text":""},{"location":"developer-guide/services/gateway-service/#client-configuration","title":"Client Configuration","text":""},{"location":"developer-guide/services/gateway-service/#developing","title":"Developing","text":""},{"location":"developer-guide/services/restconfig-v1-service/","title":"Cloud Native GeoServer REST configuration API v1 service","text":"<p>Spring Boot/Cloud microservice that exposes GeoServer REST API.</p> <p>Docker image: <code>geoservercloud/gs-cloud-restconfig-v1</code>.</p> <p>Service name: <code>restconfig-v1</code>.</p> <p>Logical service name by which the [gateway-service] will get the actual instances addresses from the [discovery-service] and perform client-side load balancing against when interacting with the service.</p>"},{"location":"developer-guide/services/restconfig-v1-service/#configuration","title":"Configuration","text":""},{"location":"developer-guide/services/restconfig-v1-service/#developing","title":"Developing","text":""}]}