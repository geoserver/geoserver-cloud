# custom property for spring.cloud.config.uri's placeholder below
# possibly externally provided short name for the location of
# the config-service when the bootstrap_config_first profile is enabled
config.server.url: http://config:8080
# custom property for eureka.client.serviceUrl.defaultZone's placeholder below
# possibly externally provided short name for the location of
# the config-service when the bootstrap_discovery_first profile is enabled
# and the the discovery-service is eureka (discovery_eureka profile is enabled) 
eureka.server.url: http://discovery:8761/eureka

info:
  component: ${spring.application.name}
  instance-id: ${spring.application.name}:${vcap.application.instance_id:${spring.application.instance_id:${spring.cloud.client.ip-address}}:${server.port}}

server:
  port: 8080
  context-path: /
  # Let spring-boot's ForwardedHeaderFilter take care of reflecting the client-originated protocol and address in the HttpServletRequest  
  forward-headers-strategy: framework
  servlet:
    context-path: /

management:
  # enable custom properties in /actuator/info like info.component
  info.env.enabled: true
  server.port: 8081
  
geoserver:
  metrics:
    enabled: true
    instance-id: ${info.instance-id}

# This default configuration is the same than applying the config_first profile group defined below.
spring:
  config:
    import: "optional:configserver:"
  profiles:
    group:
      config_first:
        - bootstrap_config_first
        - discovery_eureka
      discovery_first:
        - bootstrap_discovery_first
        - discovery_eureka
      standalone:
        - bootstrap_standalone
        - discovery_none
  main:
    banner-mode: off
    allow-bean-definition-overriding: true
    allow-circular-references: true # false by default since spring-boot 2.6.0, breaks geoserver initialization
  jmx.enabled: false
  cloud:
    config:
      # Disables the early validation check for 'spring.config.import=configserver:'.
      # This is required because our configserver entry is inside an imported file, 
      # and Spring's default validator runs before those imports are fully resolved.
      import-check.enabled: false
      enabled: true
      fail-fast: false
      retry.max-attempts: 20
      # profile config_first needs to be enabled to set the uri, otherwise we're running with no config server
      # uri: ${config.server.url:}
      discovery:
        # discovery-first config mode disabled by default, use the discovery_first profile to enable it
        enabled: false
        service-id: config-service
  integration:
    jdbc:
      # Prevents circular dependency between GeoServer's PGConfig and Spring Integration.
      # Setting this to 'never' stops the creation of 'integrationDataSourceInitializer',
      # allowing IntegrationAutoConfiguration to run (fixing the Bus NPE) without
      # trying to manage database schemas.
      initialize-schema: never
  autoconfigure:
    exclude:
      - org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration
      - org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration
      - org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration
      - org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration
      - org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration
      - org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration
      - org.springframework.boot.actuate.autoconfigure.security.servlet.ManagementWebSecurityAutoConfiguration
      - org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration
      - org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration
      - org.springframework.boot.autoconfigure.sql.init.SqlInitializationAutoConfiguration
  rabbitmq:
    host: ${rabbitmq.host:rabbitmq}
    port: ${rabbitmq.port:5672}
    username: ${rabbitmq.user:guest}
    password: ${rabbitmq.password:guest}
    virtual-host: ${rabbitmq.vhost:}

eureka:
  instance:
    hostname: ${spring.application.name}
    instance-id: ${info.instance-id}
    preferIpAddress: true
    # how often the client sends heartbits to the server
    lease-renewal-interval-in-seconds: 10
  client:
    #eureka client disabled by default, use the discovery_eureka profile to enable it
    enabled: false
    registerWithEureka: true
    #registry-fetch-interval-seconds: 10
    serviceUrl:
      defaultZone: ${eureka.server.url}
    healthcheck:
      enabled: false # must only be set to true in application.yml, not bootstrap

---
spring:
  config.activate.on-cloud-platform: none
  profiles:
    include:
    - config_first
---
#no config-service, load config from /etc/geoserver
#all Dockerfile files have the default config under that directory
spring.config.activate.on-profile: bootstrap_standalone
spring:
  config.location: ${standalone.config.location:file:/etc/geoserver/}
  cloud.config:
    enabled: false
---
#config-first bootstrap, using config-service from ${config.server.url}
spring.config.activate.on-profile: bootstrap_config_first

spring:
  cloud:
    config:
      enabled: true
      fail-fast: true
      discovery:
        enabled: false
      uri:
      - ${config.server.url}

---
#discovery-first bootstrap, first registers with discovery-service and
# gets the config-service url from it
spring.config.activate.on-profile: bootstrap_discovery_first
spring:
  cloud:
    config:
      enabled: true
      fail-fast: true
      discovery:
        enabled: true
        service-id: config-service
---
# disables all known DiscoveryClient AutoConfigurations
spring.config.activate.on-profile: discovery_none
spring:
  cloud:
    config:
      discovery:
        enabled: false
eureka.client.enabled: false
---
spring.config.activate.on-profile: discovery_eureka

eureka:
  instance:
    hostname: ${spring.application.name}
    instance-id: ${info.instance-id}
    preferIpAddress: true
    # how often the client sends heartbits to the server
    lease-renewal-interval-in-seconds: 10
  client:
    enabled: true
    registerWithEureka: true
    registry-fetch-interval-seconds: 10
    serviceUrl:
      defaultZone: ${eureka.server.url}
    healthcheck:
      enabled: false # must only be set to true in application.yml, not bootstrap

---
spring.config.activate.on-profile: offline
spring:
  cloud.config.enabled: false
  cloud.config.discovery.enabled: false
  cloud.discovery.enabled: false
  cloud.bus.enabled: false

eureka.client.enabled: false
geoserver.acl.enabled: false
---
spring.config.activate.on-profile: local
# Profile used for local development, so an app launched from the IDE can participate in the cluster.
# providing environment variables that otherwise would be given by docker-compose.yml
# It is safe to remove this profile completely in a production deployment config.
# Additionally, each service's application.yml must set the following properties in the "local" profile:
# eureka.server.url: http://localhost:8761/eureka, server.port, and management.server.port if it ought to differ from server.port
spring.rabbitmq.host: localhost
eureka.server.url: http://localhost:8761/eureka
config.server.url: http://localhost:8888
