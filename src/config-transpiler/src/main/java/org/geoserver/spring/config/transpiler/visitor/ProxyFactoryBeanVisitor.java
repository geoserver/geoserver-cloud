/* (c) 2025 Open Source Geospatial Foundation - all rights reserved
 * This code is licensed under the GPL 2.0 license, available at the root
 * application directory.
 */
package org.geoserver.spring.config.transpiler.visitor;

import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.MethodSpec;
import java.util.ArrayList;
import java.util.List;
import org.geoserver.spring.config.transpiler.context.BeanGenerationContext;
import org.geoserver.spring.config.transpiler.context.TranspilationContext;
import org.springframework.beans.PropertyValue;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.config.TypedStringValue;
import org.springframework.beans.factory.support.ManagedList;

/**
 * Visitor for generating {@code @Bean} methods for Spring AOP {@code ProxyFactoryBean} definitions.
 *
 * <h3>Problem Solved</h3>
 * <p>Spring's {@code ProxyFactoryBean} is a specialized factory bean that creates AOP proxies
 * programmatically. It requires specific handling of properties that don't follow standard
 * bean property patterns:
 *
 * <ul>
 *   <li><strong>proxyInterfaces:</strong> String class names must be converted to {@code Class<?>[]} array</li>
 *   <li><strong>interceptorNames:</strong> List of strings must be converted to {@code String[]} array</li>
 *   <li><strong>target/targetName:</strong> Reference to the actual object being proxied</li>
 * </ul>
 *
 * <h3>Spring XML Pattern</h3>
 * <pre>{@code
 * <bean id="wcs100Service" class="org.springframework.aop.framework.ProxyFactoryBean">
 *     <property name="proxyInterfaces">
 *         <value>org.geoserver.wcs.WebCoverageService100</value>
 *     </property>
 *     <property name="interceptorNames">
 *         <list>
 *             <value>wcs100Logger</value>
 *             <value>wcs100ServiceInterceptor*</value>
 *             <value>wcs100ServiceTarget</value>
 *         </list>
 *     </property>
 * </bean>
 * }</pre>
 *
 * <h3>Generated Java Output</h3>
 * <pre>{@code
 * @Bean
 * org.springframework.aop.framework.ProxyFactoryBean wcs100Service() {
 *     org.springframework.aop.framework.ProxyFactoryBean bean = new org.springframework.aop.framework.ProxyFactoryBean();
 *     bean.setProxyInterfaces(new Class<?>[] { org.geoserver.wcs.WebCoverageService100.class });
 *     bean.setInterceptorNames(new String[] { "wcs100Logger", "wcs100ServiceInterceptor*", "wcs100ServiceTarget" });
 *     return bean;
 * }
 * }</pre>
 *
 * <h3>AOP Proxy Concepts</h3>
 * <p>The {@code ProxyFactoryBean} creates dynamic proxies that wrap target objects with:
 * <ul>
 *   <li><strong>Interceptors:</strong> Method interceptors that implement cross-cutting concerns</li>
 *   <li><strong>Advisors:</strong> Combination of advice and pointcuts</li>
 *   <li><strong>Target:</strong> The actual object being proxied</li>
 *   <li><strong>Interfaces:</strong> The interfaces the proxy should implement</li>
 * </ul>
 *
 * <p>This visitor handles the transformation from XML property syntax to the correct
 * Java API calls required by {@code ProxyFactoryBean}.
 *
 * @since 2.28.0
 * @see org.springframework.aop.framework.ProxyFactoryBean
 * @see SimpleBeanVisitor
 */
public class ProxyFactoryBeanVisitor extends AbstractBeanDefinitionVisitor {

    private static final String PROXY_FACTORY_BEAN_CLASS = "org.springframework.aop.framework.ProxyFactoryBean";

    @Override
    public boolean canHandle(BeanDefinition beanDefinition, TranspilationContext context) {
        return PROXY_FACTORY_BEAN_CLASS.equals(beanDefinition.getBeanClassName());
    }

    @Override
    public int getPriority() {
        return 40; // Higher priority than SimpleBeanVisitor (200) to handle ProxyFactoryBean specifically
    }

    @Override
    public MethodSpec generateBeanMethod(BeanGenerationContext beanContext) {
        TranspilationContext transpilationContext = beanContext.getTranspilationContext();
        BeanDefinition beanDefinition = beanContext.getBeanDefinition();
        String beanName = beanContext.getBeanName();

        // Sanitize bean name for method name
        String methodName = sanitizeBeanName(beanName);

        // For auto-generated bean names, add unique suffix to avoid collisions
        if (beanContext.isAutoGenerated()) {
            String uniqueSuffix = transpilationContext.getUniqueMethodSuffix();
            methodName = methodName + "_" + uniqueSuffix;
        }

        // ProxyFactoryBean return type
        ClassName returnType = ClassName.get("org.springframework.aop.framework", "ProxyFactoryBean");

        // Create method builder
        MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(methodName)
                .addModifiers() // Package-private
                .returns(returnType)
                .addException(ClassNotFoundException.class);

        // Add {@code @Bean} annotation
        methodBuilder.addAnnotation(createBeanAnnotation(beanContext));

        // Add javadoc using enhanced bean info
        String javadocContent = beanContext.generateJavadoc();
        methodBuilder.addJavadoc(javadocContent);

        // Generate method body
        generateProxyFactoryBeanMethodBody(methodBuilder, beanDefinition);

        return methodBuilder.build();
    }

    /**
     * Generate the method body for ProxyFactoryBean with specialized property handling.
     */
    private void generateProxyFactoryBeanMethodBody(MethodSpec.Builder methodBuilder, BeanDefinition beanDefinition) {
        // Create the ProxyFactoryBean instance
        methodBuilder.addStatement(
                "$T bean = new $T()",
                ClassName.get("org.springframework.aop.framework", "ProxyFactoryBean"),
                ClassName.get("org.springframework.aop.framework", "ProxyFactoryBean"));

        // Process each property with specialized handling
        if (beanDefinition.hasPropertyValues()) {
            for (PropertyValue pv : beanDefinition.getPropertyValues().getPropertyValues()) {
                String propertyName = pv.getName();
                Object value = pv.getValue();

                switch (propertyName) {
                    case "proxyInterfaces":
                        generateProxyInterfacesSetter(methodBuilder, value);
                        break;
                    case "interceptorNames":
                        generateInterceptorNamesSetter(methodBuilder, value);
                        break;
                    case "target":
                    case "targetName":
                        generateTargetSetter(methodBuilder, propertyName, value);
                        break;
                    default:
                        // Handle other properties using standard setter generation
                        generateStandardSetter(methodBuilder, propertyName, value);
                        break;
                }
            }
        }

        methodBuilder.addStatement("return bean");
    }

    /**
     * Generate setter for proxyInterfaces property - converts string class names to Class<?>[].
     */
    private void generateProxyInterfacesSetter(MethodSpec.Builder methodBuilder, Object value) {
        if (value instanceof TypedStringValue stringValue1) {
            // Single interface
            String interfaceClassName = stringValue1.getValue();
            methodBuilder.addStatement(
                    "bean.setProxyInterfaces(new Class<?>[] { Class.forName($S) })", interfaceClassName);
        } else if (value instanceof ManagedList<?> managedList) {
            List<String> interfaceNames = new ArrayList<>();

            for (Object item : managedList) {
                if (item instanceof TypedStringValue stringValue) {
                    interfaceNames.add(stringValue.getValue());
                }
            }

            if (interfaceNames.size() == 1) {
                methodBuilder.addStatement(
                        "bean.setProxyInterfaces(new Class<?>[] { Class.forName($S) })", interfaceNames.get(0));
            } else if (interfaceNames.size() > 1) {
                // Generate array with multiple interfaces
                CodeBlock.Builder arrayBuilder = CodeBlock.builder().add("new Class<?>[] { ");
                for (int i = 0; i < interfaceNames.size(); i++) {
                    if (i > 0) {
                        arrayBuilder.add(", ");
                    }
                    arrayBuilder.add("Class.forName($S)", interfaceNames.get(i));
                }
                arrayBuilder.add(" }");
                methodBuilder.addStatement("bean.setProxyInterfaces($L)", arrayBuilder.build());
            }
        }
    }

    /**
     * Generate setter for interceptorNames property - converts List<String> to String[].
     */
    private void generateInterceptorNamesSetter(MethodSpec.Builder methodBuilder, Object value) {
        if (value instanceof ManagedList<?> managedList) {
            List<String> interceptorNames = new ArrayList<>();

            for (Object item : managedList) {
                if (item instanceof TypedStringValue stringValue) {
                    interceptorNames.add(stringValue.getValue());
                }
            }

            if (interceptorNames.size() == 1) {
                methodBuilder.addStatement("bean.setInterceptorNames(new String[] { $S })", interceptorNames.get(0));
            } else if (interceptorNames.size() > 1) {
                // Generate array with multiple interceptor names
                CodeBlock.Builder arrayBuilder = CodeBlock.builder().add("new String[] { ");
                for (int i = 0; i < interceptorNames.size(); i++) {
                    if (i > 0) {
                        arrayBuilder.add(", ");
                    }
                    arrayBuilder.add("$S", interceptorNames.get(i));
                }
                arrayBuilder.add(" }");
                methodBuilder.addStatement("bean.setInterceptorNames($L)", arrayBuilder.build());
            }
        }
    }

    /**
     * Generate setter for target/targetName properties.
     */
    private void generateTargetSetter(MethodSpec.Builder methodBuilder, String propertyName, Object value) {
        // Convert property name to setter method name
        String setterName = "set" + Character.toUpperCase(propertyName.charAt(0)) + propertyName.substring(1);

        if (value instanceof org.springframework.beans.factory.config.RuntimeBeanReference beanRef) {
            methodBuilder.addComment("TODO: Add method parameter for bean reference: " + beanRef.getBeanName());
            methodBuilder.addStatement(
                    "// bean.$L($L); // Bean reference: $L",
                    setterName,
                    sanitizeBeanName(beanRef.getBeanName()),
                    beanRef.getBeanName());
        } else if (value instanceof TypedStringValue typedStringValue) {
            String stringValue = typedStringValue.getValue();
            methodBuilder.addStatement("bean.$L($S)", setterName, stringValue);
        }
    }

    /**
     * Generate standard setter for other properties.
     */
    private void generateStandardSetter(MethodSpec.Builder methodBuilder, String propertyName, Object value) {
        String setterName = "set" + Character.toUpperCase(propertyName.charAt(0)) + propertyName.substring(1);

        if (value instanceof TypedStringValue typedStringValue) {
            String stringValue = typedStringValue.getValue();
            methodBuilder.addStatement("bean.$L($S)", setterName, stringValue);
        } else {
            // For other types, add a comment indicating they need special handling
            methodBuilder.addComment(
                    "TODO: Handle property '$L' of type $L",
                    propertyName,
                    value.getClass().getSimpleName());
        }
    }
}
