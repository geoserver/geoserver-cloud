/* (c) 2025 Open Source Geospatial Foundation - all rights reserved
 * This code is licensed under the GPL 2.0 license, available at the root
 * application directory.
 */
package org.geoserver.spring.config.transpiler.context;

import java.util.List;
import org.springframework.beans.factory.config.BeanDefinition;

/**
 * Context object that holds information specific to generating a single bean method.
 *
 * <p>This context is created for each bean definition being processed and contains:
 * <ul>
 *   <li>The bean name and definition from the XML</li>
 *   <li>Reference to the shared TranspilationContext</li>
 *   <li>Bean-specific metadata and configuration</li>
 *   <li>Derived information needed for code generation</li>
 * </ul>
 *
 * <p>Multiple BeanGenerationContext instances share the same TranspilationContext
 * reference since we're generating multiple beans within the same transpilation process.
 *
 * @since 2.28.0
 * @see TranspilationContext
 */
public class BeanGenerationContext {

    private final EnhancedBeanInfo enhancedBeanInfo;
    private final TranspilationContext transpilationContext;

    // Bean metadata
    private String beanClassName; // Lazily resolved to handle parent inheritance
    private final boolean hasConstructorArgs;
    private final boolean hasPropertyValues;
    private final boolean hasFactoryMethod;

    private BeanGenerationContext(Builder builder) {
        this.enhancedBeanInfo = builder.enhancedBeanInfo;
        this.transpilationContext = builder.transpilationContext;

        // Derive metadata from bean definition
        BeanDefinition beanDefinition =
                enhancedBeanInfo != null ? enhancedBeanInfo.getBeanDefinition() : builder.beanDefinition;
        this.beanClassName = null; // Will be resolved lazily when getBeanClassName() is called
        this.hasConstructorArgs = beanDefinition.hasConstructorArgumentValues();
        this.hasPropertyValues = beanDefinition.hasPropertyValues();
        this.hasFactoryMethod = beanDefinition.getFactoryMethodName() != null;
    }

    // Getters
    public String getBeanName() {
        return enhancedBeanInfo.getName();
    }

    public BeanDefinition getBeanDefinition() {
        return enhancedBeanInfo.getBeanDefinition();
    }

    public boolean isAutoGenerated() {
        return getBeanInfo().isAutoGenerated();
    }

    public List<String> getAliases() {
        return getBeanInfo().getAliases();
    }

    public boolean shouldIncludeInBeanAnnotation() {
        return getBeanInfo().shouldIncludeInBeanAnnotation();
    }

    public String generateJavadoc() {
        return getBeanInfo().generateJavadoc();
    }

    public String getSanitizedMethodName() {
        return getBeanInfo().getSanitizedMethodName();
    }

    public EnhancedBeanInfo getBeanInfo() {
        return enhancedBeanInfo;
    }

    public String getBeanClassName() {
        if (beanClassName == null) {
            // Lazy resolution of bean class name including parent inheritance
            beanClassName = deriveBeanClassName(getBeanDefinition());
        }
        return beanClassName;
    }

    public boolean hasConstructorArgs() {
        return hasConstructorArgs;
    }

    public boolean hasPropertyValues() {
        return hasPropertyValues;
    }

    public boolean hasFactoryMethod() {
        return hasFactoryMethod;
    }

    public TranspilationContext getTranspilationContext() {
        return transpilationContext;
    }

    /**
     * Get the bean's return type for the {@code @Bean} method.
     */
    public String getBeanReturnType() {
        // Use the resolved bean class name or fall back to Object
        return beanClassName != null ? beanClassName : "java.lang.Object";
    }

    /**
     * Get all names for this bean (original name + aliases).
     * Used for generating the {@code @Bean} annotation name parameter.
     *
     * @return list containing the original bean name followed by aliases
     */
    public java.util.List<String> getAllNames() {
        return java.util.Arrays.asList(enhancedBeanInfo.getAllBeanNames());
    }

    private String deriveBeanClassName(BeanDefinition beanDefinition) {
        String beanClassName = beanDefinition.getBeanClassName();
        if (beanClassName != null) {
            return beanClassName;
        }

        // Try Spring's ResolvableType first - it handles inheritance properly
        try {
            org.springframework.core.ResolvableType resolvableType = beanDefinition.getResolvableType();
            if (resolvableType != null && resolvableType != org.springframework.core.ResolvableType.NONE) {
                Class<?> resolvedClass = resolvableType.resolve();
                if (resolvedClass != null) {
                    return resolvedClass.getName();
                }
            }
        } catch (Exception e) {
            // Continue to manual parent resolution
        }

        // Fallback: Handle bean inheritance - resolve class name from parent bean
        if (beanDefinition.getParentName() != null && transpilationContext != null) {
            String parentName = beanDefinition.getParentName();
            BeanDefinition parentBean = transpilationContext.getBeanDefinition(parentName);
            if (parentBean != null) {
                // Recursively resolve parent's class name (handles chained inheritance)
                String parentClassName = deriveBeanClassName(parentBean);
                if (parentClassName != null) {
                    return parentClassName;
                }
            }
        }

        // Handle factory beans or other special cases
        if (beanDefinition.getFactoryBeanName() != null) {
            // Factory bean case - we might need to look up the factory bean's type
            return null; // Will be resolved later
        }

        return null; // Unknown type - will use Object as fallback
    }

    // Builder pattern implementation

    public static Builder builder() {
        return new Builder();
    }

    public static class Builder {
        private String beanName;
        private BeanDefinition beanDefinition;
        private EnhancedBeanInfo enhancedBeanInfo;
        private TranspilationContext transpilationContext;

        public Builder beanName(String beanName) {
            this.beanName = beanName;
            return this;
        }

        public Builder beanDefinition(BeanDefinition beanDefinition) {
            this.beanDefinition = beanDefinition;
            return this;
        }

        public Builder enhancedBeanInfo(EnhancedBeanInfo enhancedBeanInfo) {
            this.enhancedBeanInfo = enhancedBeanInfo;
            return this;
        }

        public Builder transpilationContext(TranspilationContext transpilationContext) {
            this.transpilationContext = transpilationContext;
            return this;
        }

        public BeanGenerationContext build() {
            if (transpilationContext == null) {
                throw new IllegalStateException("transpilationContext is required");
            }
            if (enhancedBeanInfo == null) {
                throw new IllegalStateException("enhancedBeanInfo is required");
            }

            return new BeanGenerationContext(this);
        }
    }
}
