/* (c) 2025 Open Source Geospatial Foundation - all rights reserved
 * This code is licensed under the GPL 2.0 license, available at the root
 * application directory.
 */
package org.geoserver.spring.config.transpiler.visitor;

import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterSpec;
import java.util.ArrayList;
import java.util.List;
import javax.lang.model.element.Modifier;
import org.geoserver.spring.config.transpiler.context.BeanGenerationContext;
import org.geoserver.spring.config.transpiler.context.TranspilationContext;
import org.geoserver.spring.config.transpiler.util.TypeNameResolver;
import org.springframework.beans.PropertyValue;
import org.springframework.beans.PropertyValues;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.config.RuntimeBeanReference;
import org.springframework.beans.factory.config.TypedStringValue;
import org.springframework.context.annotation.DependsOn;
import org.springframework.context.annotation.Lazy;
import org.springframework.context.annotation.Scope;

/**
 * Fallback (low priority) visitor for generating {@code @Bean} methods for simple beans.
 *
 * <p>This visitor handles the simplest case of Spring bean definitions:
 * beans with no constructor arguments, no factory methods, and minimal
 * configuration. It serves as a fallback when more specialized visitors
 * cannot handle a particular bean definition.
 *
 * <p>Generated {@code @Bean} methods will use default (no-argument) constructors
 * and may apply property values using setter methods if needed.
 *
 * @since 2.28.0
 */
public class SimpleBeanVisitor extends AbstractBeanDefinitionVisitor {

    @Override
    public boolean canHandle(BeanDefinition beanDefinition, TranspilationContext context) {
        // Handle simple beans as a fallback
        // This should handle beans that other visitors can't process
        return beanDefinition.getBeanClassName() != null && !beanDefinition.isAbstract();
    }

    @Override
    public MethodSpec generateBeanMethod(BeanGenerationContext beanContext) {
        TranspilationContext transpilationContext = beanContext.getTranspilationContext();
        BeanDefinition beanDefinition = beanContext.getBeanDefinition();
        String beanName = beanContext.getBeanName();
        String beanClassName = beanContext.getBeanClassName();

        // Sanitize bean name for method name
        String methodName = sanitizeBeanName(beanName);

        // For auto-generated bean names, add unique suffix to avoid collisions across configurations
        if (beanContext.isAutoGenerated()) {
            String uniqueSuffix = transpilationContext.getUniqueMethodSuffix();
            methodName = methodName + "_" + uniqueSuffix;
        }

        // {@code @Bean} methods are always package-private per Spring conventions
        // Only {@code @Configuration} class visibility is controlled by publicAccess
        Modifier[] methodModifiers = new Modifier[0]; // Package-private

        // Get return type using TypeNameResolver
        ClassName returnType = getReturnType(beanContext, transpilationContext);

        // Create method builder
        MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(methodName)
                .addModifiers(methodModifiers)
                .returns(returnType);

        // Add {@code @Bean} annotation with proper name handling
        methodBuilder.addAnnotation(createBeanAnnotation(beanContext));

        // Add @SuppressWarnings if needed for managed collections
        addSuppressWarningsIfNeeded(methodBuilder, beanDefinition);

        // Add @Lazy annotation if bean has lazy-init="true"
        if (beanDefinition.isLazyInit()) {
            methodBuilder.addAnnotation(Lazy.class);
        }

        // Add @Scope annotation if bean has non-default scope
        if (beanDefinition.getScope() != null
                && !beanDefinition.getScope().isEmpty()
                && !"singleton".equals(beanDefinition.getScope())) {
            AnnotationSpec scopeAnnotation = AnnotationSpec.builder(Scope.class)
                    .addMember("value", "$S", beanDefinition.getScope())
                    .build();
            methodBuilder.addAnnotation(scopeAnnotation);
        }

        // Add @DependsOn annotation if bean has depends-on attribute
        String[] dependsOn = beanDefinition.getDependsOn();
        if (dependsOn != null && dependsOn.length > 0) {
            AnnotationSpec.Builder dependsOnBuilder = AnnotationSpec.builder(DependsOn.class);
            if (dependsOn.length == 1) {
                dependsOnBuilder.addMember("value", "$S", dependsOn[0]);
            } else {
                CodeBlock.Builder arrayBuilder = CodeBlock.builder().add("{");
                for (int i = 0; i < dependsOn.length; i++) {
                    if (i > 0) {
                        arrayBuilder.add(", ");
                    }
                    arrayBuilder.add("$S", dependsOn[i]);
                }
                arrayBuilder.add("}");
                dependsOnBuilder.addMember("value", arrayBuilder.build());
            }
            methodBuilder.addAnnotation(dependsOnBuilder.build());
        }

        // Add javadoc using enhanced bean info
        String javadocContent = beanContext.generateJavadoc();
        methodBuilder.addJavadoc(javadocContent);

        // Generate method body
        generateMethodBody(
                methodBuilder,
                beanContext,
                beanDefinition,
                beanClassName,
                returnType,
                transpilationContext.getAllBeanDefinitions(),
                transpilationContext);

        return methodBuilder.build();
    }

    @Override
    public int getPriority() {
        return 200; // Low priority - fallback visitor
    }

    /**
     * Generate the method body for simple bean creation.
     */
    private void generateMethodBody(
            MethodSpec.Builder methodBuilder,
            BeanGenerationContext beanContext,
            BeanDefinition beanDefinition,
            String beanClassName,
            ClassName returnType,
            java.util.Map<String, BeanDefinition> allBeanDefinitions,
            TranspilationContext transpilationContext) {
        if (beanClassName == null) {
            methodBuilder.addStatement(
                    "throw new $T($S)", UnsupportedOperationException.class, "No bean class name specified");
            return;
        }

        boolean hasProperties = beanContext.hasPropertyValues();

        if (hasProperties) {
            // Need to handle property values
            methodBuilder.addJavadoc("Note: Property values will be applied using setter methods\n");

            // Collect bean references from properties
            List<String> propertyBeanReferences = collectPropertyBeanReferences(beanDefinition.getPropertyValues());

            // Add method parameters for property bean references with proper types
            for (String beanRef : propertyBeanReferences) {
                // Find the property name for this bean reference
                String propertyName = findPropertyNameForBeanRef(beanRef, beanDefinition.getPropertyValues());

                // Use enhanced type inference from base class
                ClassName paramType = resolveParameterTypeWithInference(
                        beanRef, beanClassName, null, propertyName, null, transpilationContext);

                ParameterSpec.Builder paramBuilder = ParameterSpec.builder(paramType, sanitizeBeanName(beanRef))
                        .addAnnotation(AnnotationSpec.builder(Qualifier.class)
                                .addMember("value", "$S", beanRef)
                                .build());
                methodBuilder.addParameter(paramBuilder.build());
            }

            // Create bean instance and set properties
            if (requiresReflectionForDefaultConstructor(beanClassName)) {
                // Use reflection for protected/private constructors
                generateReflectionConstructorCall(methodBuilder, beanClassName, returnType, "bean");
            } else {
                methodBuilder.addStatement("$T bean = new $T()", returnType, returnType);
            }
            generatePropertySetters(
                    methodBuilder,
                    beanDefinition.getPropertyValues(),
                    propertyBeanReferences,
                    beanClassName,
                    beanContext.getBeanName());
            methodBuilder.addStatement("return bean");
        } else {
            // Simple case: no properties - direct instantiation
            if (requiresReflectionForDefaultConstructor(beanClassName)) {
                // Use reflection for protected/private constructors
                generateReflectionConstructorCall(methodBuilder, beanClassName, returnType, null);
            } else {
                methodBuilder.addStatement("return new $T()", returnType);
            }
        }
    }

    /**
     * Collect bean references from property values, including SpEL bean references in ManagedProperties.
     */
    private List<String> collectPropertyBeanReferences(PropertyValues propertyValues) {
        List<String> beanReferences = new ArrayList<>();

        for (PropertyValue pv : propertyValues.getPropertyValues()) {
            Object value = pv.getValue();
            if (value instanceof RuntimeBeanReference beanRef) {
                beanReferences.add(sanitizeBeanName(beanRef.getBeanName()));
            } else if (value instanceof org.springframework.beans.factory.support.ManagedProperties managedProps) {
                for (Object propVal : managedProps.values()) {
                    String propValStr = extractStringValue(propVal);
                    String simpleBeanRef = extractSimpleSpelBeanReference(propValStr);
                    if (simpleBeanRef != null && !beanReferences.contains(simpleBeanRef)) {
                        beanReferences.add(sanitizeBeanName(simpleBeanRef));
                    }
                }
            } else if (value instanceof org.springframework.beans.factory.support.ManagedList<?> managedList) {
                List<String> listBeanRefs = collectBeanReferencesFromManagedList(managedList);
                for (String beanRef : listBeanRefs) {
                    String sanitizedBeanRef = sanitizeBeanName(beanRef);
                    if (!beanReferences.contains(sanitizedBeanRef)) {
                        beanReferences.add(sanitizedBeanRef);
                    }
                }
            }
        }

        return beanReferences;
    }

    /**
     * Generate property setter method calls with proper type conversion.
     */
    private void generatePropertySetters(
            MethodSpec.Builder methodBuilder,
            PropertyValues propertyValues,
            List<String> beanReferences,
            String beanClassName,
            String beanName) {
        int beanRefIndex = 0;

        for (PropertyValue pv : propertyValues.getPropertyValues()) {
            String propertyName = pv.getName();
            Object value = pv.getValue();

            // Generate setter method name
            String setterName = "set" + Character.toUpperCase(propertyName.charAt(0)) + propertyName.substring(1);

            if (value instanceof RuntimeBeanReference) {
                // Use bean reference parameter
                if (beanRefIndex < beanReferences.size()) {
                    methodBuilder.addStatement("bean.$L($N)", setterName, beanReferences.get(beanRefIndex++));
                }
            } else if (value instanceof TypedStringValue stringValue) {
                String rawValue = stringValue.getValue();

                // Generate the converted value statement based on property type
                generateTypedPropertySetterCall(methodBuilder, setterName, propertyName, rawValue, beanClassName);
            } else if (value instanceof org.springframework.beans.factory.support.ManagedProperties managedProps) {
                // Handle ManagedProperties (like <props>)
                methodBuilder.addComment("// Property '" + propertyName + "' uses ManagedProperties");
                methodBuilder.addStatement(
                        "java.util.Properties $L = new java.util.Properties()", propertyName + "Props");

                for (Object key : managedProps.keySet()) {
                    Object val = managedProps.get(key);

                    String keyStr = extractStringValue(key);
                    String valStr = extractStringValue(val);

                    // Check if the value is a simple SpEL bean reference
                    String simpleBeanRef = extractSimpleSpelBeanReference(valStr);
                    if (simpleBeanRef != null) {
                        // Use bean reference parameter variable instead of literal SpEL
                        methodBuilder.addStatement(
                                "$L.setProperty($S, $N)", propertyName + "Props", keyStr, simpleBeanRef);
                    } else {
                        // Use literal string value
                        methodBuilder.addStatement("$L.setProperty($S, $S)", propertyName + "Props", keyStr, valStr);
                    }
                }

                methodBuilder.addStatement("bean.$L($L)", setterName, propertyName + "Props");
            } else if (value instanceof org.springframework.beans.factory.support.ManagedMap<?, ?> managedMap) {
                // Handle ManagedMap (like <map>)
                methodBuilder.addComment("// Property '" + propertyName + "' uses ManagedMap");

                // Check if this is a Map<Class<?>, Class<?>> based on property type analysis
                boolean isClassMap = isClassToClassMap(propertyName, beanClassName);

                if (isClassMap) {
                    // Use raw Map to avoid complex generic issues - the @SuppressWarnings annotation handles this
                    methodBuilder.addStatement("java.util.Map $L = new java.util.HashMap()", propertyName + "Map");
                } else {
                    methodBuilder.addStatement(
                            "java.util.Map<String, Object> $L = new java.util.HashMap<>()", propertyName + "Map");
                }

                for (java.util.Map.Entry<?, ?> entry : managedMap.entrySet()) {
                    String keyStr = extractStringValue(entry.getKey());
                    String valStr = extractStringValue(entry.getValue());

                    if (isClassMap) {
                        // Convert strings to Class literals
                        methodBuilder.addStatement("$L.put($L.class, $L.class)", propertyName + "Map", keyStr, valStr);
                    } else {
                        methodBuilder.addStatement("$L.put($S, $S)", propertyName + "Map", keyStr, valStr);
                    }
                }

                methodBuilder.addStatement("bean.$L($L)", setterName, propertyName + "Map");
            } else if (value instanceof org.springframework.beans.factory.support.ManagedList<?> managedList) {
                // Handle ManagedList (like <list> with bean references for method arguments)
                methodBuilder.addComment("// Property '" + propertyName + "' uses ManagedList");

                // Check if the setter method expects varargs
                if (isVarargsSetterMethod(setterName, beanClassName)) {
                    // Generate varargs call: bean.setInterceptors(item1, item2, ...)
                    generateVarargsSetterCall(methodBuilder, setterName, managedList);
                } else {
                    // Generate list call: bean.setProperty(new ArrayList<>(...))
                    String listCall = generateManagedListCall(managedList);
                    methodBuilder.addStatement("bean.$L($L)", setterName, listCall);
                }
            } else if (value
                    instanceof org.springframework.beans.factory.config.BeanDefinitionHolder nestedBeanHolder) {
                // Handle nested bean definitions - simple object instantiation
                generateNestedBeanPropertySetter(methodBuilder, setterName, nestedBeanHolder);
            } else {
                // Fallback for other value types
                methodBuilder.addComment("TODO: Handle property '" + propertyName + "' of type "
                        + value.getClass().getSimpleName());
            }
        }
    }

    private ClassName getReturnType(BeanGenerationContext beanContext, TranspilationContext context) {
        // Use TypeNameResolver for proper type resolution
        TypeNameResolver.TypeResolutionResult result =
                TypeNameResolver.resolveBeanReturnType(beanContext.getBeanDefinition(), context);

        if (!result.isResolved()) {
            return ClassName.get(Object.class);
        }

        String typeName = result.getResolvedTypeName();
        try {
            if (typeName.contains(".")) {
                int lastDot = typeName.lastIndexOf('.');
                String packageName = typeName.substring(0, lastDot);
                String simpleName = typeName.substring(lastDot + 1);
                return ClassName.get(packageName, simpleName);
            } else {
                return ClassName.get("java.lang", typeName);
            }
        } catch (Exception e) {
            return ClassName.get(Object.class);
        }
    }

    /**
     * Resolve parameter type using TypeNameResolver.
     */
    private ClassName resolveParameterType(
            String beanRef, java.util.Map<String, BeanDefinition> allBeanDefinitions, TranspilationContext context) {
        if (allBeanDefinitions == null) {
            return ClassName.get(Object.class);
        }

        TypeNameResolver.TypeResolutionResult result =
                TypeNameResolver.resolveDependencyType(beanRef, allBeanDefinitions, context);

        if (!result.isResolved()) {
            return ClassName.get(Object.class);
        }

        String typeName = result.getResolvedTypeName();
        try {
            if (typeName.contains(".")) {
                int lastDot = typeName.lastIndexOf('.');
                String packageName = typeName.substring(0, lastDot);
                String simpleName = typeName.substring(lastDot + 1);
                return ClassName.get(packageName, simpleName);
            } else {
                return ClassName.get("java.lang", typeName);
            }
        } catch (Exception e) {
            return ClassName.get(Object.class);
        }
    }

    /**
     * Check if a property expects a Map<Class<?>, Class<?>> by analyzing the property type.
     * This is needed for properties like CustomEditorConfigurer.customEditors.
     */
    private boolean isClassToClassMap(String propertyName, String beanClassName) {
        try {
            Class<?> propertyType = getPropertyType(propertyName, beanClassName);

            // Check if it's a Map type
            if (java.util.Map.class.isAssignableFrom(propertyType)) {
                // For now, use a simple heuristic: if the property name contains "editor"
                // and the bean is CustomEditorConfigurer, assume it's a Class->Class map
                if (propertyName.toLowerCase().contains("editor") && beanClassName.contains("CustomEditorConfigurer")) {
                    return true;
                }
            }

            return false;
        } catch (Exception e) {
            // If we can't determine the type, assume it's not a class map
            return false;
        }
    }

    /**
     * Find the property name that references a specific bean.
     */
    private String findPropertyNameForBeanRef(String beanRef, PropertyValues propertyValues) {
        for (PropertyValue pv : propertyValues.getPropertyValues()) {
            Object value = pv.getValue();
            if (value instanceof RuntimeBeanReference ref && ref.getBeanName().equals(beanRef)) {
                return pv.getName();
            }
        }
        return null;
    }

    /**
     * Check if a setter method expects varargs instead of a List parameter.
     * Uses reflection to examine the method signature.
     */
    private boolean isVarargsSetterMethod(String setterName, String beanClassName) {
        if (beanClassName == null) {
            return false;
        }

        try {
            Class<?> beanClass = Class.forName(beanClassName);
            java.lang.reflect.Method[] methods = beanClass.getMethods();

            for (java.lang.reflect.Method method : methods) {
                if (method.getName().equals(setterName) && method.isVarArgs()) {
                    return true;
                }
            }
        } catch (ClassNotFoundException e) {
            // If we can't load the class, assume it's not varargs
            return false;
        }

        return false;
    }

    /**
     * Generate a varargs setter call for ManagedList properties.
     * Generates: bean.setInterceptors(item1, item2, ...)
     */
    private void generateVarargsSetterCall(
            com.squareup.javapoet.MethodSpec.Builder methodBuilder,
            String setterName,
            org.springframework.beans.factory.support.ManagedList<?> managedList) {

        StringBuilder argsBuilder = new StringBuilder();
        boolean first = true;

        for (Object listItem : managedList) {
            if (!first) {
                argsBuilder.append(", ");
            }
            first = false;

            if (listItem instanceof org.springframework.beans.factory.config.RuntimeBeanReference beanRef) {
                // Use sanitized bean name as parameter - this must match the method parameter names
                String sanitizedBeanName = sanitizeBeanName(beanRef.getBeanName());
                argsBuilder.append(sanitizedBeanName);
            } else if (listItem instanceof org.springframework.beans.factory.config.TypedStringValue stringValue) {
                // Extract the actual string value from TypedStringValue
                argsBuilder.append("\"").append(stringValue.getValue()).append("\"");
            } else {
                // Other types - convert to string for now
                argsBuilder.append("\"").append(listItem.toString()).append("\"");
            }
        }

        methodBuilder.addStatement("bean.$L($L)", setterName, argsBuilder.toString());
    }
}
