/* (c) 2025 Open Source Geospatial Foundation - all rights reserved
 * This code is licensed under the GPL 2.0 license, available at the root
 * application directory.
 */
package org.geoserver.spring.config.transpiler.visitor;

import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterSpec;
import java.util.ArrayList;
import java.util.List;
import javax.lang.model.element.Modifier;
import org.geoserver.spring.config.transpiler.context.BeanGenerationContext;
import org.geoserver.spring.config.transpiler.context.TranspilationContext;
import org.geoserver.spring.config.transpiler.util.TypeNameResolver;
import org.springframework.beans.PropertyValue;
import org.springframework.beans.PropertyValues;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.config.RuntimeBeanReference;
import org.springframework.context.annotation.DependsOn;
import org.springframework.context.annotation.Lazy;
import org.springframework.context.annotation.Scope;

/**
 * Fallback (low priority) visitor for generating {@code @Bean} methods for simple beans.
 *
 * <p>This visitor handles the simplest case of Spring bean definitions:
 * beans with no constructor arguments, no factory methods, and minimal
 * configuration. It serves as a fallback when more specialized visitors
 * cannot handle a particular bean definition.
 *
 * <p>Generated {@code @Bean} methods will use default (no-argument) constructors
 * and may apply property values using setter methods if needed.
 *
 * @since 2.28.0
 */
public class SimpleBeanVisitor extends AbstractBeanDefinitionVisitor {

    @Override
    public boolean canHandle(BeanDefinition beanDefinition, TranspilationContext context) {
        // Handle simple beans as a fallback
        // This should handle beans that other visitors can't process
        return beanDefinition.getBeanClassName() != null && !beanDefinition.isAbstract();
    }

    @Override
    public MethodSpec generateBeanMethod(BeanGenerationContext beanContext) {
        TranspilationContext transpilationContext = beanContext.getTranspilationContext();
        BeanDefinition beanDefinition = beanContext.getBeanDefinition();
        String beanName = beanContext.getBeanName();
        String beanClassName = beanContext.getBeanClassName();

        // Sanitize bean name for method name
        String methodName = sanitizeBeanName(beanName);

        // For auto-generated bean names, add unique suffix to avoid collisions across configurations
        if (beanContext.isAutoGenerated()) {
            String uniqueSuffix = transpilationContext.getUniqueMethodSuffix();
            methodName = methodName + "_" + uniqueSuffix;
        }

        // {@code @Bean} methods are always package-private per Spring conventions
        // Only {@code @Configuration} class visibility is controlled by publicAccess
        Modifier[] methodModifiers = new Modifier[0]; // Package-private

        // Get return type using TypeNameResolver
        ClassName returnType = getReturnType(beanContext, transpilationContext);

        // Create method builder
        MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(methodName)
                .addModifiers(methodModifiers)
                .returns(returnType);

        // Add {@code @Bean} annotation with proper name handling
        methodBuilder.addAnnotation(createBeanAnnotation(beanContext));

        // Add @SuppressWarnings if needed for managed collections
        addSuppressWarningsIfNeeded(methodBuilder, beanDefinition);

        // Add @Lazy annotation if bean has lazy-init="true"
        if (beanDefinition.isLazyInit()) {
            methodBuilder.addAnnotation(Lazy.class);
        }

        // Add @Scope annotation if bean has non-default scope
        if (beanDefinition.getScope() != null
                && !beanDefinition.getScope().isEmpty()
                && !"singleton".equals(beanDefinition.getScope())) {
            AnnotationSpec scopeAnnotation = AnnotationSpec.builder(Scope.class)
                    .addMember("value", "$S", beanDefinition.getScope())
                    .build();
            methodBuilder.addAnnotation(scopeAnnotation);
        }

        // Add @DependsOn annotation if bean has depends-on attribute
        String[] dependsOn = beanDefinition.getDependsOn();
        if (dependsOn != null && dependsOn.length > 0) {
            AnnotationSpec.Builder dependsOnBuilder = AnnotationSpec.builder(DependsOn.class);
            if (dependsOn.length == 1) {
                dependsOnBuilder.addMember("value", "$S", dependsOn[0]);
            } else {
                CodeBlock.Builder arrayBuilder = CodeBlock.builder().add("{");
                for (int i = 0; i < dependsOn.length; i++) {
                    if (i > 0) {
                        arrayBuilder.add(", ");
                    }
                    arrayBuilder.add("$S", dependsOn[i]);
                }
                arrayBuilder.add("}");
                dependsOnBuilder.addMember("value", arrayBuilder.build());
            }
            methodBuilder.addAnnotation(dependsOnBuilder.build());
        }

        // Add javadoc using enhanced bean info
        String javadocContent = beanContext.generateJavadoc();
        methodBuilder.addJavadoc(javadocContent);

        // Generate method body
        generateMethodBody(
                methodBuilder,
                beanContext,
                beanDefinition,
                beanClassName,
                returnType,
                transpilationContext.getAllBeanDefinitions(),
                transpilationContext);

        return methodBuilder.build();
    }

    @Override
    public int getPriority() {
        return 200; // Low priority - fallback visitor
    }

    /**
     * Generate the method body for simple bean creation.
     */
    private void generateMethodBody(
            MethodSpec.Builder methodBuilder,
            BeanGenerationContext beanContext,
            BeanDefinition beanDefinition,
            String beanClassName,
            ClassName returnType,
            java.util.Map<String, BeanDefinition> allBeanDefinitions,
            TranspilationContext transpilationContext) {
        if (beanClassName == null) {
            methodBuilder.addStatement(
                    "throw new $T($S)", UnsupportedOperationException.class, "No bean class name specified");
            return;
        }

        // Add constructor exceptions to method signature (for no-arg constructor)
        addConstructorExceptions(methodBuilder, beanClassName, null);

        boolean hasProperties = beanContext.hasPropertyValues();

        if (hasProperties) {
            // Need to handle property values
            methodBuilder.addJavadoc("Note: Property values will be applied using setter methods\n");

            // Collect bean references from properties
            List<String> propertyBeanReferences = collectPropertyBeanReferences(beanDefinition.getPropertyValues());

            // Add method parameters for property bean references with proper types
            for (String beanRef : propertyBeanReferences) {
                // Find the property name for this bean reference
                String propertyName = findPropertyNameForBeanRef(beanRef, beanDefinition.getPropertyValues());

                // Use enhanced type inference from base class
                ClassName paramType = resolveParameterTypeWithInference(
                        beanRef, beanClassName, null, propertyName, null, transpilationContext);

                ParameterSpec.Builder paramBuilder = ParameterSpec.builder(paramType, sanitizeBeanName(beanRef))
                        .addAnnotation(AnnotationSpec.builder(Qualifier.class)
                                .addMember("value", "$S", beanRef)
                                .build());
                methodBuilder.addParameter(paramBuilder.build());
            }

            // Create bean instance and set properties
            if (requiresReflectionForDefaultConstructor(beanClassName)) {
                // Use reflection for protected/private constructors
                generateReflectionConstructorCall(methodBuilder, beanClassName, returnType, "bean");
            } else {
                methodBuilder.addStatement("$T bean = new $T()", returnType, returnType);
            }
            // Use the unified generatePropertySetters method from base class
            generatePropertySetters(
                    methodBuilder,
                    beanDefinition.getPropertyValues(),
                    propertyBeanReferences,
                    beanClassName,
                    beanContext.getBeanName());
            methodBuilder.addStatement("return bean");
        } else {
            // Simple case: no properties - direct instantiation
            if (requiresReflectionForDefaultConstructor(beanClassName)) {
                // Use reflection for protected/private constructors
                generateReflectionConstructorCall(methodBuilder, beanClassName, returnType, null);
            } else {
                methodBuilder.addStatement("return new $T()", returnType);
            }
        }
    }

    /**
     * Collect bean references from property values, including SpEL bean references in ManagedProperties.
     */
    private List<String> collectPropertyBeanReferences(PropertyValues propertyValues) {
        List<String> beanReferences = new ArrayList<>();

        for (PropertyValue pv : propertyValues.getPropertyValues()) {
            Object value = pv.getValue();
            if (value instanceof RuntimeBeanReference beanRef) {
                beanReferences.add(sanitizeBeanName(beanRef.getBeanName()));
            } else if (value instanceof org.springframework.beans.factory.support.ManagedProperties managedProps) {
                for (Object propVal : managedProps.values()) {
                    String propValStr = extractStringValue(propVal);
                    String simpleBeanRef = extractSimpleSpelBeanReference(propValStr);
                    if (simpleBeanRef != null && !beanReferences.contains(simpleBeanRef)) {
                        beanReferences.add(sanitizeBeanName(simpleBeanRef));
                    }
                }
            } else if (value instanceof org.springframework.beans.factory.support.ManagedList<?> managedList) {
                List<String> listBeanRefs = collectBeanReferencesFromManagedList(managedList);
                for (String beanRef : listBeanRefs) {
                    String sanitizedBeanRef = sanitizeBeanName(beanRef);
                    if (!beanReferences.contains(sanitizedBeanRef)) {
                        beanReferences.add(sanitizedBeanRef);
                    }
                }
            }
        }

        return beanReferences;
    }

    private ClassName getReturnType(BeanGenerationContext beanContext, TranspilationContext context) {
        // Use TypeNameResolver for proper type resolution
        TypeNameResolver.TypeResolutionResult result =
                TypeNameResolver.resolveBeanReturnType(beanContext.getBeanDefinition(), context);

        if (!result.isResolved()) {
            return ClassName.get(Object.class);
        }

        String typeName = result.getResolvedTypeName();
        try {
            if (typeName.contains(".")) {
                int lastDot = typeName.lastIndexOf('.');
                String packageName = typeName.substring(0, lastDot);
                String simpleName = typeName.substring(lastDot + 1);
                return ClassName.get(packageName, simpleName);
            } else {
                return ClassName.get("java.lang", typeName);
            }
        } catch (Exception e) {
            return ClassName.get(Object.class);
        }
    }

    /**
     * Resolve parameter type using TypeNameResolver.
     */
    private ClassName resolveParameterType(
            String beanRef, java.util.Map<String, BeanDefinition> allBeanDefinitions, TranspilationContext context) {
        if (allBeanDefinitions == null) {
            return ClassName.get(Object.class);
        }

        TypeNameResolver.TypeResolutionResult result =
                TypeNameResolver.resolveDependencyType(beanRef, allBeanDefinitions, context);

        if (!result.isResolved()) {
            return ClassName.get(Object.class);
        }

        String typeName = result.getResolvedTypeName();
        try {
            if (typeName.contains(".")) {
                int lastDot = typeName.lastIndexOf('.');
                String packageName = typeName.substring(0, lastDot);
                String simpleName = typeName.substring(lastDot + 1);
                return ClassName.get(packageName, simpleName);
            } else {
                return ClassName.get("java.lang", typeName);
            }
        } catch (Exception e) {
            return ClassName.get(Object.class);
        }
    }

    /**
     * Find the property name that references a specific bean.
     */
    private String findPropertyNameForBeanRef(String beanRef, PropertyValues propertyValues) {
        for (PropertyValue pv : propertyValues.getPropertyValues()) {
            Object value = pv.getValue();
            if (value instanceof RuntimeBeanReference ref && ref.getBeanName().equals(beanRef)) {
                return pv.getName();
            }
        }
        return null;
    }
}
