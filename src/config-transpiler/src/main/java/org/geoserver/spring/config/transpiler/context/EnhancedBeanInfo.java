/* (c) 2025 Open Source Geospatial Foundation - all rights reserved
 * This code is licensed under the GPL 2.0 license, available at the root
 * application directory.
 */
package org.geoserver.spring.config.transpiler.context;

import java.util.ArrayList;
import java.util.List;
import org.springframework.beans.factory.config.BeanDefinition;
import org.w3c.dom.Element;

/**
 * Enhanced bean information containing both Spring's processed data,
 * the original XML structure, and bean name resolution metadata.
 *
 * <p>This consolidates all information needed for bean method generation,
 * eliminating the need for separate BeanNameResolver.BeanNameInfo objects.
 */
public final class EnhancedBeanInfo {
    private final String originalName;
    private final BeanDefinition beanDefinition;
    private final Element originalElement;
    private final List<String> aliases;
    private final List<String> explicitAliases; // Only aliases from separate <alias> elements

    // Bean name resolution fields
    private final String sanitizedMethodName;
    private final boolean isAutoGenerated;
    private final boolean shouldIncludeInBeanAnnotation;

    public EnhancedBeanInfo(
            String name, BeanDefinition beanDefinition, Element originalElement, String[] initialAliases) {
        this.originalName = name;
        this.beanDefinition = beanDefinition;
        this.originalElement = originalElement;
        this.aliases = new ArrayList<>();
        this.explicitAliases = new ArrayList<>(); // Initially empty, populated later for actual <alias> elements
        if (initialAliases != null) {
            for (String alias : initialAliases) {
                this.aliases.add(alias);
            }
        }

        // Compute name resolution information
        this.sanitizedMethodName = sanitizeBeanName(name);
        this.isAutoGenerated = isAutoGeneratedName(name);
        this.shouldIncludeInBeanAnnotation = shouldIncludeNameInBeanAnnotation(name, this.sanitizedMethodName);
    }

    public String getName() {
        return originalName;
    }

    public String getOriginalName() {
        return originalName;
    }

    public BeanDefinition getBeanDefinition() {
        return beanDefinition;
    }

    public Element getOriginalElement() {
        return originalElement;
    }

    public List<String> getAliases() {
        return aliases;
    }

    public String getSanitizedMethodName() {
        return sanitizedMethodName;
    }

    public boolean isAutoGenerated() {
        return isAutoGenerated;
    }

    public boolean shouldIncludeInBeanAnnotation() {
        return shouldIncludeInBeanAnnotation;
    }

    public void addAlias(String alias) {
        if (!aliases.contains(alias)) {
            aliases.add(alias);
        }
        // Also add to explicit aliases - this method is called for <alias> elements
        if (!explicitAliases.contains(alias)) {
            explicitAliases.add(alias);
        }
    }

    /**
     * Get all bean names including the primary name and all aliases
     */
    public String[] getAllBeanNames() {
        if (aliases.isEmpty()) {
            return new String[] {originalName};
        }

        String[] allNames = new String[aliases.size() + 1];
        allNames[0] = originalName;
        for (int i = 0; i < aliases.size(); i++) {
            allNames[i + 1] = aliases.get(i);
        }
        return allNames;
    }

    /**
     * Generate Javadoc block with original XML configuration
     */
    public String generateJavadoc() {
        // Use original XML element if available, otherwise reconstruct
        String xmlToUse = null;
        if (originalElement != null) {
            xmlToUse = elementToString(originalElement);
        }

        if (xmlToUse == null || xmlToUse.trim().isEmpty()) {
            xmlToUse = reconstructXmlFromBeanDefinition();
        }

        if (xmlToUse == null || xmlToUse.trim().isEmpty()) {
            // Final fallback to simple javadoc
            String className = beanDefinition.getBeanClassName();
            if (className != null) {
                return "Simple bean instantiation for " + className + "\n";
            }
            return "Generated bean method\n";
        }

        // Split the XML into lines and clean up empty lines
        String[] lines = xmlToUse.split("\n");
        StringBuilder javadoc = new StringBuilder();
        javadoc.append("Generated from XML configuration:\n");
        javadoc.append("{@snippet lang=xml :\n");
        for (String line : lines) {
            // Skip completely empty lines or lines with only whitespace
            if (line.trim().length() > 0) {
                // Escape $ characters for JavaPoet ($ is treated as format specifier)
                String escapedLine = line.replace("$", "$$");
                // Escape /* and */ sequences that can break Javadoc comments
                escapedLine = escapedLine.replace("/*", "/&#42;").replace("*/", "&#42;/");
                javadoc.append(escapedLine).append("\n");
            }
        }
        for (String alias : explicitAliases) {
            javadoc.append("""
                           <alias name="%s" alias="%s"/>
                           """
                    .formatted(getName(), alias));
        }
        javadoc.append("}\n");
        return javadoc.toString();
    }

    /**
     * Convert DOM Element to XML string preserving original formatting for Javadoc
     */
    private String elementToString(Element element) {
        try {
            // Try to preserve original formatting by not applying any transformation
            javax.xml.transform.TransformerFactory tf = javax.xml.transform.TransformerFactory.newInstance();
            javax.xml.transform.Transformer transformer = tf.newTransformer();
            transformer.setOutputProperty(javax.xml.transform.OutputKeys.OMIT_XML_DECLARATION, "yes");

            transformer.setOutputProperty(javax.xml.transform.OutputKeys.INDENT, "yes");
            transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "4");

            java.io.StringWriter writer = new java.io.StringWriter();
            transformer.transform(
                    new javax.xml.transform.dom.DOMSource(element),
                    new javax.xml.transform.stream.StreamResult(writer));
            return writer.toString().trim();
        } catch (Exception e) {
            // Fallback to simple representation
            return element.toString();
        }
    }

    /**
     * Reconstruct XML snippet from BeanDefinition when original XML is not available.
     */
    private String reconstructXmlFromBeanDefinition() {
        if (beanDefinition == null) {
            return null;
        }

        StringBuilder xml = new StringBuilder();

        // Start bean tag
        xml.append("<bean");

        // Add id attribute only if the bean name is not auto-generated
        if (originalName != null && originalName.length() > 0 && !isAutoGenerated) {
            xml.append(" id=\"").append(originalName).append("\"");
        }

        // Add class attribute
        String className = beanDefinition.getBeanClassName();
        if (className != null) {
            xml.append(" class=\"").append(className).append("\"");
        }

        // Add depends-on attribute
        String[] dependsOn = beanDefinition.getDependsOn();
        if (dependsOn != null && dependsOn.length > 0) {
            xml.append(" depends-on=\"").append(String.join(",", dependsOn)).append("\"");
        }

        // Add lazy-init attribute
        if (beanDefinition.isLazyInit()) {
            xml.append(" lazy-init=\"true\"");
        }

        // Add scope attribute
        String scope = beanDefinition.getScope();
        if (scope != null && !scope.isEmpty() && !"singleton".equals(scope)) {
            xml.append(" scope=\"").append(scope).append("\"");
        }

        // Check if we have constructor args or properties
        boolean hasConstructorArgs = beanDefinition.hasConstructorArgumentValues();
        boolean hasProperties = beanDefinition.hasPropertyValues();

        if (!hasConstructorArgs && !hasProperties) {
            // Self-closing tag
            xml.append("/>");
        } else {
            xml.append(">\n");

            // Add constructor arguments (simplified version)
            if (hasConstructorArgs) {
                xml.append("    <!-- Constructor arguments omitted for brevity -->\n");
            }

            // Add properties (simplified version)
            if (hasProperties) {
                xml.append("    <!-- Properties omitted for brevity -->\n");
            }

            xml.append("</bean>");
        }

        return xml.toString();
    }

    // Bean name utility methods (consolidated from BeanNameResolver)

    /**
     * Sanitize a bean name to be a valid Java method identifier.
     */
    private static String sanitizeBeanName(String beanName) {
        if (beanName == null || beanName.isEmpty()) {
            return "unknownBean";
        }

        // Replace non-alphanumeric characters with underscores
        String sanitized = beanName.replaceAll("[^a-zA-Z0-9_]", "_");

        // Ensure it starts with a letter or underscore (Java identifier rules)
        if (!Character.isJavaIdentifierStart(sanitized.charAt(0))) {
            sanitized = "_" + sanitized;
        }

        // Handle reserved Java keywords
        if (isJavaReservedWord(sanitized)) {
            sanitized = sanitized + "_";
        }

        return sanitized;
    }

    /**
     * Check if a bean name is auto-generated by Spring (e.g., className#0, className#1).
     */
    private static boolean isAutoGeneratedName(String beanName) {
        if (beanName == null) {
            return false;
        }
        // Spring auto-generates names in the format: fullyQualifiedClassName#0, fullyQualifiedClassName#1, etc.
        return beanName.matches(".*#\\d+$");
    }

    /**
     * Determine whether to include the name attribute in the {@code @Bean} annotation.
     */
    private static boolean shouldIncludeNameInBeanAnnotation(String originalBeanName, String sanitizedMethodName) {
        if (originalBeanName == null || sanitizedMethodName == null) {
            return false;
        }

        // Don't include name for auto-generated bean names
        if (isAutoGeneratedName(originalBeanName)) {
            return false;
        }

        // Don't include name if it matches the method name exactly
        if (originalBeanName.equals(sanitizedMethodName)) {
            return false;
        }

        return true;
    }

    /**
     * Check if a string is a Java reserved word.
     */
    private static boolean isJavaReservedWord(String word) {
        // Common Java reserved words
        return switch (word) {
            case "abstract",
                    "continue",
                    "for",
                    "new",
                    "switch",
                    "assert",
                    "default",
                    "goto",
                    "package",
                    "synchronized",
                    "boolean",
                    "do",
                    "if",
                    "private",
                    "this",
                    "break",
                    "double",
                    "implements",
                    "protected",
                    "throw",
                    "byte",
                    "else",
                    "import",
                    "public",
                    "throws",
                    "case",
                    "enum",
                    "instanceof",
                    "return",
                    "transient",
                    "catch",
                    "extends",
                    "int",
                    "short",
                    "try",
                    "char",
                    "final",
                    "interface",
                    "static",
                    "void",
                    "class",
                    "finally",
                    "long",
                    "strictfp",
                    "volatile",
                    "const",
                    "float",
                    "native",
                    "super",
                    "while" -> true;
            default -> false;
        };
    }
}
