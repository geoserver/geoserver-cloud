/* (c) 2025 Open Source Geospatial Foundation - all rights reserved
 * This code is licensed under the GPL 2.0 license, available at the root
 * application directory.
 */
package org.geoserver.spring.config.transpiler.visitor;

import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.MethodSpec;
import java.beans.BeanInfo;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.util.Map;
import org.geoserver.spring.config.transpiler.context.BeanGenerationContext;
import org.geoserver.spring.config.transpiler.util.TypeNameResolver;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.config.ConstructorArgumentValues;
import org.springframework.beans.factory.config.RuntimeBeanReference;
import org.springframework.beans.factory.config.TypedStringValue;
import org.springframework.beans.factory.support.ManagedMap;
import org.springframework.beans.factory.support.ManagedProperties;
import org.springframework.context.annotation.Bean;

/**
 * Abstract base class for bean definition visitors that provides common
 * functionality.
 *
 * <p>
 * This base class contains shared logic for:
 * <ul>
 * <li>Creating {@code @Bean} annotations with proper name handling</li>
 * <li>Common utility methods for bean method generation</li>
 * </ul>
 *
 * @since 2.28.0
 */
public abstract class AbstractBeanDefinitionVisitor implements BeanDefinitionVisitor {

    /**
     * Create {@code @Bean} annotation with proper name handling for all bean names
     * (original + aliases). This logic handles both single names and multiple names
     * correctly.
     *
     * @param beanContext the bean generation context containing name information
     * @return properly configured {@code @Bean} annotation
     */
    protected AnnotationSpec createBeanAnnotation(BeanGenerationContext beanContext) {
        AnnotationSpec.Builder beanAnnotationBuilder = AnnotationSpec.builder(Bean.class);

        // Get all names using the utility method from BeanGenerationContext
        java.util.List<String> allNames = beanContext.getAllNames();

        // Include name parameter based on consolidated EnhancedBeanInfo logic, with
        // special handling for aliases
        boolean shouldIncludeName = beanContext.shouldIncludeInBeanAnnotation();

        // For non-auto-generated names, include name parameter if there are aliases
        // But for auto-generated names (e.g., ClassName#0), respect the original
        // decision
        if (!shouldIncludeName && !beanContext.isAutoGenerated()) {
            // Only override for non-auto-generated names when there are aliases
            shouldIncludeName = !beanContext.getAliases().isEmpty();
        }

        if (shouldIncludeName) {
            if (allNames.size() == 1) {
                // Single name
                beanAnnotationBuilder.addMember("name", "$S", allNames.get(0));
            } else {
                // Multiple names (original + aliases) - create array
                CodeBlock.Builder arrayBuilder = CodeBlock.builder().add("{");
                for (int i = 0; i < allNames.size(); i++) {
                    if (i > 0) {
                        arrayBuilder.add(", ");
                    }
                    arrayBuilder.add("$S", allNames.get(i));
                }
                arrayBuilder.add("}");
                beanAnnotationBuilder.addMember("name", arrayBuilder.build());
            }
        }

        return beanAnnotationBuilder.build();
    }

    /**
     * Add @SuppressWarnings annotation if the bean has property values that require
     * it. This is needed when dealing with ManagedMap or ManagedProperties which
     * use raw types.
     *
     * @param methodBuilder  the method builder to add the annotation to
     * @param beanDefinition the bean definition to check for managed collections
     */
    protected void addSuppressWarningsIfNeeded(MethodSpec.Builder methodBuilder, BeanDefinition beanDefinition) {
        boolean hasMapProperties = beanDefinition.getPropertyValues().getPropertyValueList().stream()
                .anyMatch(
                        pv -> pv.getValue() instanceof ManagedMap<?, ?> || pv.getValue() instanceof ManagedProperties);

        if (hasMapProperties) {
            AnnotationSpec suppressWarnings = AnnotationSpec.builder(SuppressWarnings.class)
                    .addMember("value", "{$S, $S}", "unchecked", "rawtypes")
                    .build();
            methodBuilder.addAnnotation(suppressWarnings);
        }
    }

    /**
     * Generate a property setter call with proper type conversion based on the
     * target property type. Uses Spring's BeanWrapper introspection for accurate
     * type resolution.
     *
     * @param methodBuilder the method builder to add statements to
     * @param setterName    the setter method name (e.g., "setOrder")
     * @param propertyName  the property name (e.g., "order")
     * @param rawValue      the string value from XML
     * @param beanClassName the bean class name for type introspection
     */
    protected void generateTypedPropertySetterCall(
            MethodSpec.Builder methodBuilder,
            String setterName,
            String propertyName,
            String rawValue,
            String beanClassName) {

        // Determine the property type using BeanWrapper introspection (fail fast if not
        // found)
        Class<?> propertyType = getPropertyType(propertyName, beanClassName);

        if (propertyType == boolean.class || propertyType == Boolean.class) {
            // Boolean properties
            boolean boolValue = "true".equalsIgnoreCase(rawValue);
            methodBuilder.addStatement("bean.$L($L)", setterName, boolValue);
        } else if (propertyType == int.class || propertyType == Integer.class) {
            // Integer properties - validate and fail fast if invalid
            try {
                Integer.parseInt(rawValue); // Validate it's a valid integer
                methodBuilder.addStatement("bean.$L($L)", setterName, rawValue);
            } catch (NumberFormatException e) {
                throw new IllegalArgumentException(
                        "Property '" + propertyName + "' expects an integer but got: '" + rawValue + "'", e);
            }
        } else if (propertyType == long.class || propertyType == Long.class) {
            // Long properties - validate and fail fast if invalid
            try {
                Long.parseLong(rawValue); // Validate it's a valid long
                methodBuilder.addStatement("bean.$L($LL)", setterName, rawValue);
            } catch (NumberFormatException e) {
                throw new IllegalArgumentException(
                        "Property '" + propertyName + "' expects a long but got: '" + rawValue + "'", e);
            }
        } else if (propertyType == double.class || propertyType == Double.class) {
            // Double properties - validate and fail fast if invalid
            try {
                Double.parseDouble(rawValue); // Validate it's a valid double
                methodBuilder.addStatement("bean.$L($LD)", setterName, rawValue);
            } catch (NumberFormatException e) {
                throw new IllegalArgumentException(
                        "Property '" + propertyName + "' expects a double but got: '" + rawValue + "'", e);
            }
        } else if (propertyType == float.class || propertyType == Float.class) {
            // Float properties - validate and fail fast if invalid
            try {
                Float.parseFloat(rawValue); // Validate it's a valid float
                methodBuilder.addStatement("bean.$L($LF)", setterName, rawValue);
            } catch (NumberFormatException e) {
                throw new IllegalArgumentException(
                        "Property '" + propertyName + "' expects a float but got: '" + rawValue + "'", e);
            }
        } else if (propertyType != String.class && hasStringConstructor(propertyType)) {
            // Property expects a non-String type that can be constructed from a string
            methodBuilder.addStatement("bean.$L(new $T($S))", setterName, propertyType, rawValue);
        } else {
            // String or other object properties (default case)
            methodBuilder.addStatement("bean.$L($S)", setterName, rawValue);
        }
    }

    /**
     * Get the property type for a given property name using Java Beans
     * introspection. This provides accurate type information for proper code
     * generation without requiring class instantiation.
     *
     * @param propertyName  the property name to introspect
     * @param beanClassName the fully qualified bean class name
     * @return the property type class
     * @throws IllegalArgumentException if property is not found
     * @throws RuntimeException         if class cannot be loaded or introspected
     */
    protected Class<?> getPropertyType(String propertyName, String beanClassName) {
        if (beanClassName == null) {
            throw new IllegalArgumentException("Bean class name cannot be null for property type resolution");
        }

        try {
            // Load the bean class
            Class<?> beanClass = Class.forName(beanClassName);

            // Use Java Beans Introspector to analyze properties without instantiation
            BeanInfo beanInfo = Introspector.getBeanInfo(beanClass);
            PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors();

            // Find the property descriptor for the specific property
            for (PropertyDescriptor propertyDescriptor : propertyDescriptors) {
                if (propertyName.equals(propertyDescriptor.getName())) {
                    return propertyDescriptor.getPropertyType();
                }
            }

            throw new IllegalArgumentException("Property '" + propertyName + "' not found on class " + beanClassName);

        } catch (ClassNotFoundException e) {
            throw new RuntimeException(
                    "Cannot find class '" + beanClassName + "' for property type resolution. "
                            + "Make sure the class is on the compilation classpath.",
                    e);
        } catch (Exception e) {
            throw new RuntimeException(
                    "Failed to introspect property '" + propertyName + "' on class " + beanClassName, e);
        }
    }

    /**
     * Extract the actual string value from Spring framework objects like
     * TypedStringValue. This handles the common case where XML values are wrapped
     * in Spring's internal objects.
     *
     * @param obj the object to extract value from
     * @return the string value
     */
    protected String extractStringValue(Object obj) {
        if (obj instanceof TypedStringValue value) {
            return value.getValue();
        } else if (obj instanceof String string) {
            return string;
        } else {
            return obj.toString();
        }
    }

    /**
     * Extract simple SpEL bean reference from a string value. Returns the bean name
     * if the value is a simple SpEL expression like #{beanName}, otherwise returns
     * null.
     */
    protected String extractSimpleSpelBeanReference(String value) {
        if (value == null || value.trim().isEmpty()) {
            return null;
        }

        String trimmed = value.trim();

        // Check if it's a simple SpEL bean reference: #{beanName}
        if (trimmed.startsWith("#{") && trimmed.endsWith("}")) {
            String spelContent = trimmed.substring(2, trimmed.length() - 1).trim();

            // Simple bean reference: just a valid Java identifier (no operators, spaces,
            // quotes, etc.)
            if (spelContent.matches("[a-zA-Z_][a-zA-Z0-9_]*")) {
                return spelContent;
            }
        }

        return null;
    }

    /**
     * Generate a ManagedList constructor call using ArrayList with bean references.
     * Based on the pattern from the old spring-factory-processor ManagedListHelper.
     * This creates a list constructor argument where bean references become method
     * parameters. Uses ArrayList instead of List.of() for Spring runtime compatibility.
     *
     * @param managedList the ManagedList to process
     * @return the generated ArrayList construction call string
     */
    protected String generateManagedListCall(org.springframework.beans.factory.support.ManagedList<?> managedList) {
        StringBuilder listCall = new StringBuilder("new java.util.ArrayList<>(java.util.List.of(");

        boolean first = true;
        for (Object listItem : managedList) {
            if (!first) {
                listCall.append(", ");
            }
            first = false;

            if (listItem instanceof RuntimeBeanReference beanRef) {
                // Use sanitized bean name as parameter - this must match the method parameter names
                String sanitizedBeanName = sanitizeBeanName(beanRef.getBeanName());
                listCall.append(sanitizedBeanName);
            } else if (listItem instanceof org.springframework.beans.factory.config.TypedStringValue stringValue) {
                // Extract the actual string value from TypedStringValue
                listCall.append("\"").append(stringValue.getValue()).append("\"");
            } else {
                // Other types - convert to string for now
                listCall.append("\"").append(listItem.toString()).append("\"");
            }
        }
        listCall.append("))");
        return listCall.toString();
    }

    /**
     * Collect bean references from a ManagedList. This is used to determine which
     * method parameters need to be added for list constructor arguments.
     *
     * @param managedList the ManagedList to analyze
     * @return list of bean reference names that should become method parameters
     */
    protected java.util.List<String> collectBeanReferencesFromManagedList(
            org.springframework.beans.factory.support.ManagedList<?> managedList) {
        java.util.List<String> beanReferences = new java.util.ArrayList<>();

        for (Object listItem : managedList) {
            if (listItem instanceof RuntimeBeanReference beanRef) {
                beanReferences.add(
                        beanRef.getBeanName()); // Note: This method returns raw names, callers should sanitize if
                // needed for JavaPoet
            }
        }

        return beanReferences;
    }

    /**
     * Resolve parameter type for a bean reference using TypeNameResolver. This
     * provides consistent type resolution across all visitors.
     *
     * @param beanName             the bean name to resolve type for
     * @param transpilationContext the transpilation context containing bean
     *                             definitions
     * @return the resolved parameter type as ClassName
     */
    protected com.squareup.javapoet.ClassName resolveParameterType(
            String beanName, org.geoserver.spring.config.transpiler.context.TranspilationContext transpilationContext) {
        Map<String, BeanDefinition> allBeanDefinitions = transpilationContext.getAllBeanDefinitions();
        if (allBeanDefinitions == null || allBeanDefinitions.isEmpty()) {
            return com.squareup.javapoet.ClassName.get(Object.class);
        }

        TypeNameResolver.TypeResolutionResult result =
                TypeNameResolver.resolveDependencyType(beanName, allBeanDefinitions, transpilationContext);

        if (!result.isResolved()) {
            return com.squareup.javapoet.ClassName.get(Object.class);
        }

        String typeName = result.getResolvedTypeName();
        try {
            if (typeName.contains(".")) {
                int lastDot = typeName.lastIndexOf('.');
                String packageName = typeName.substring(0, lastDot);
                String simpleName = typeName.substring(lastDot + 1);
                return com.squareup.javapoet.ClassName.get(packageName, simpleName);
            } else {
                return com.squareup.javapoet.ClassName.get("java.lang", typeName);
            }
        } catch (Exception e) {
            return com.squareup.javapoet.ClassName.get(Object.class);
        }
    }

    /**
     * Get the boxed type ClassName for a primitive type.
     */
    protected ClassName getBoxedType(Class<?> clazz) {
        if (clazz == int.class) {
            return ClassName.get(Integer.class);
        } else if (clazz == long.class) {
            return ClassName.get(Long.class);
        } else if (clazz == double.class) {
            return ClassName.get(Double.class);
        } else if (clazz == float.class) {
            return ClassName.get(Float.class);
        } else if (clazz == boolean.class) {
            return ClassName.get(Boolean.class);
        } else if (clazz == byte.class) {
            return ClassName.get(Byte.class);
        } else if (clazz == short.class) {
            return ClassName.get(Short.class);
        } else if (clazz == char.class) {
            return ClassName.get(Character.class);
        }
        throw new IllegalArgumentException("Unknown primitive type: " + clazz);
    }

    /**
     * Resolve parameter type for bean references with enhanced type inference.
     * This method tries multiple strategies to find the most appropriate parameter type:
     * 1. Constructor parameter type (if paramIndex provided and beanClassName available)
     * 2. Property setter parameter type (if propertyName provided and beanClassName available)
     * 3. Fallback to referenced bean's type
     *
     * @param beanName the name of the referenced bean
     * @param beanClassName the class name of the bean being created (for reflection)
     * @param paramIndex optional constructor parameter index (for constructor injection)
     * @param propertyName optional property name (for setter injection)
     * @param constructorArgs optional constructor arguments (for parameter count validation)
     * @param transpilationContext the transpilation context
     * @return the resolved parameter type
     */
    protected ClassName resolveParameterTypeWithInference(
            String beanName,
            String beanClassName,
            Integer paramIndex,
            String propertyName,
            ConstructorArgumentValues constructorArgs,
            org.geoserver.spring.config.transpiler.context.TranspilationContext transpilationContext) {

        // Strategy 1: Constructor parameter type inference
        if (paramIndex != null && beanClassName != null) {
            try {
                Class<?> expectedType = getConstructorParameterType(paramIndex, beanClassName, constructorArgs);
                if (expectedType != null) {
                    return ClassName.get(expectedType);
                }
            } catch (Exception e) {
                // Continue to next strategy
            }
        }

        // Strategy 2: Property setter parameter type inference
        if (propertyName != null && beanClassName != null) {
            try {
                Class<?> setterParamType = getPropertyType(propertyName, beanClassName);
                if (setterParamType != null) {
                    return ClassName.get(setterParamType);
                }
            } catch (Exception e) {
                // Continue to fallback
            }
        }

        // Strategy 3: Fallback to referenced bean type
        return resolveParameterType(beanName, transpilationContext);
    }

    /**
     * Get constructor parameter type using reflection.
     */
    private Class<?> getConstructorParameterType(
            int paramIndex, String beanClassName, ConstructorArgumentValues constructorArgs) {
        if (beanClassName == null) {
            return null;
        }

        try {
            Class<?> beanClass = Class.forName(beanClassName);

            if (constructorArgs == null || constructorArgs.isEmpty()) {
                // Handle implicit constructor autowiring
                java.lang.reflect.Constructor<?> constructor = findConstructorForAutowiring(beanClass);
                if (constructor != null && paramIndex < constructor.getParameterCount()) {
                    return constructor.getParameterTypes()[paramIndex];
                }
            } else {
                // Handle explicit constructor arguments
                int argCount = constructorArgs.getArgumentCount();
                java.lang.reflect.Constructor<?>[] constructors = beanClass.getDeclaredConstructors();

                // First try to find a public constructor with matching parameter count
                for (java.lang.reflect.Constructor<?> constructor : constructors) {
                    if (constructor.getParameterCount() == argCount
                            && paramIndex < constructor.getParameterCount()
                            && java.lang.reflect.Modifier.isPublic(constructor.getModifiers())) {
                        return constructor.getParameterTypes()[paramIndex];
                    }
                }

                // If no public constructor found, fall back to any constructor with matching count
                for (java.lang.reflect.Constructor<?> constructor : constructors) {
                    if (constructor.getParameterCount() == argCount && paramIndex < constructor.getParameterCount()) {
                        return constructor.getParameterTypes()[paramIndex];
                    }
                }
            }
        } catch (Exception e) {
            // Return null to indicate failure
        }

        return null;
    }

    /**
     * Find constructor suitable for autowiring (typically the one with most parameters).
     */
    private java.lang.reflect.Constructor<?> findConstructorForAutowiring(Class<?> beanClass) {
        java.lang.reflect.Constructor<?>[] constructors = beanClass.getDeclaredConstructors();

        // First try to find a public constructor
        java.lang.reflect.Constructor<?> bestPublicConstructor = null;
        for (java.lang.reflect.Constructor<?> constructor : constructors) {
            if (java.lang.reflect.Modifier.isPublic(constructor.getModifiers())) {
                if (bestPublicConstructor == null
                        || constructor.getParameterCount() > bestPublicConstructor.getParameterCount()) {
                    bestPublicConstructor = constructor;
                }
            }
        }

        if (bestPublicConstructor != null) {
            return bestPublicConstructor;
        }

        // If no public constructor, find the one with most parameters
        java.lang.reflect.Constructor<?> bestConstructor = null;
        for (java.lang.reflect.Constructor<?> constructor : constructors) {
            if (bestConstructor == null || constructor.getParameterCount() > bestConstructor.getParameterCount()) {
                bestConstructor = constructor;
            }
        }

        return bestConstructor;
    }

    /**
     * Get the generic element type for a collection constructor parameter.
     * For example, if the constructor parameter is List&lt;Service&gt;, this returns Service.
     */
    protected ClassName getGenericCollectionElementType(
            int paramIndex, String beanClassName, ConstructorArgumentValues constructorArgs) {
        if (beanClassName == null) {
            return null;
        }

        try {
            Class<?> beanClass = Class.forName(beanClassName);
            int argCount = constructorArgs.getArgumentCount();
            java.lang.reflect.Constructor<?>[] constructors = beanClass.getDeclaredConstructors();

            // Find constructor with matching parameter count
            for (java.lang.reflect.Constructor<?> constructor : constructors) {
                if (constructor.getParameterCount() == argCount && paramIndex < constructor.getParameterCount()) {
                    java.lang.reflect.Type genericType = constructor.getGenericParameterTypes()[paramIndex];

                    // Check if it's a parameterized type (e.g., List<Service>)
                    if (genericType instanceof java.lang.reflect.ParameterizedType parameterizedType) {
                        java.lang.reflect.Type[] typeArguments = parameterizedType.getActualTypeArguments();
                        if (typeArguments.length > 0 && typeArguments[0] instanceof Class<?> elementClass) {
                            return ClassName.get(elementClass);
                        }
                    }
                    break;
                }
            }
        } catch (Exception e) {
            // Fall back to null if we can't determine the generic type
        }

        return null;
    }

    /**
     * Sanitize bean name to be a valid Java method identifier.
     * This method is used by all visitors to ensure consistent bean name sanitization.
     */
    protected String sanitizeBeanName(String beanName) {
        if (beanName == null || beanName.isEmpty()) {
            return "unknownBean";
        }

        // Replace non-alphanumeric characters with underscores
        String sanitized = beanName.replaceAll("[^a-zA-Z0-9_]", "_");

        // Ensure it starts with a letter or underscore (Java identifier rules)
        if (!Character.isJavaIdentifierStart(sanitized.charAt(0))) {
            sanitized = "_" + sanitized;
        }

        // Handle reserved Java keywords
        if (isJavaReservedWord(sanitized)) {
            sanitized = sanitized + "_";
        }

        return sanitized;
    }

    /**
     * Check if a type has a constructor that accepts a single String parameter.
     * This method uses reflection to determine if a non-String type can be constructed from a String.
     */
    protected boolean hasStringConstructor(Class<?> type) {
        if (type == null || type == String.class) {
            return false;
        }

        try {
            // Check for common types that have String constructors
            if (type.getName().equals("org.geotools.util.Version")) {
                return true;
            }

            // Use reflection to check for String constructor
            type.getConstructor(String.class);
            return true;
        } catch (NoSuchMethodException e) {
            return false;
        }
    }

    /**
     * Check if the default (no-argument) constructor requires reflection-based instantiation.
     * This is needed for protected or private constructors.
     */
    protected boolean requiresReflectionForDefaultConstructor(String beanClassName) {
        if (beanClassName == null) {
            return false;
        }

        try {
            Class<?> beanClass = Class.forName(beanClassName);

            // Try to get the no-argument constructor
            java.lang.reflect.Constructor<?> constructor = beanClass.getDeclaredConstructor();

            // Check if constructor is public
            return !java.lang.reflect.Modifier.isPublic(constructor.getModifiers());
        } catch (ClassNotFoundException | NoSuchMethodException e) {
            // If we can't find the class or constructor, assume public access
            return false;
        }
    }

    /**
     * Generate reflection-based constructor instantiation for no-argument constructors.
     * This handles protected/private constructors that can't be called directly.
     *
     * @param methodBuilder the method builder to add statements to
     * @param beanClassName the fully qualified class name
     * @param returnType the return type for casting
     * @param variableName the variable name to create ("bean" for properties, null for direct return)
     */
    protected void generateReflectionConstructorCall(
            MethodSpec.Builder methodBuilder, String beanClassName, ClassName returnType, String variableName) {

        methodBuilder.addStatement(
                "java.lang.reflect.Constructor constructor = java.lang.Class.forName($S).getDeclaredConstructor()",
                beanClassName);
        methodBuilder.addStatement("constructor.setAccessible(true)");

        if (variableName != null) {
            // Create variable for property setting
            methodBuilder.addStatement("$T $L = ($T) constructor.newInstance()", returnType, variableName, returnType);
        } else {
            // Direct return
            methodBuilder.addStatement("return ($T) constructor.newInstance()", returnType);
        }

        // Add exception to method signature for reflection
        methodBuilder.addException(ClassName.get(Exception.class));
    }

    /**
     * Check if a string is a Java reserved word.
     */
    private boolean isJavaReservedWord(String word) {
        // Common Java reserved words
        return switch (word) {
            case "abstract",
                    "continue",
                    "for",
                    "new",
                    "switch",
                    "assert",
                    "default",
                    "goto",
                    "package",
                    "synchronized",
                    "boolean",
                    "do",
                    "if",
                    "private",
                    "this",
                    "break",
                    "double",
                    "implements",
                    "protected",
                    "throw",
                    "byte",
                    "else",
                    "import",
                    "public",
                    "throws",
                    "case",
                    "enum",
                    "instanceof",
                    "return",
                    "transient",
                    "catch",
                    "extends",
                    "int",
                    "short",
                    "try",
                    "char",
                    "final",
                    "interface",
                    "static",
                    "void",
                    "class",
                    "finally",
                    "long",
                    "strictfp",
                    "volatile",
                    "const",
                    "float",
                    "native",
                    "super",
                    "while" -> true;
            default -> false;
        };
    }

    /**
     * Generate a property setter call for nested bean definitions.
     * This handles two patterns:
     * 1. FieldRetrievingFactoryBean pattern: generates static field references
     * 2. Simple object constructor pattern: generates direct instantiation
     */
    protected void generateNestedBeanPropertySetter(
            MethodSpec.Builder methodBuilder,
            String setterName,
            org.springframework.beans.factory.config.BeanDefinitionHolder nestedBeanHolder) {

        BeanDefinition nestedBeanDefinition = nestedBeanHolder.getBeanDefinition();
        String nestedBeanClassName = nestedBeanDefinition.getBeanClassName();

        if (nestedBeanClassName == null) {
            methodBuilder.addComment("// Nested bean has no class name - cannot instantiate");
            return;
        }

        // Check if this is a FieldRetrievingFactoryBean
        if ("org.springframework.beans.factory.config.FieldRetrievingFactoryBean".equals(nestedBeanClassName)) {
            // Handle FieldRetrievingFactoryBean pattern
            String beanId = nestedBeanHolder.getBeanName();
            if (beanId != null
                    && beanId.contains(".")
                    && Character.isUpperCase(beanId.charAt(beanId.lastIndexOf('.') + 1))) {
                // Bean ID looks like: org.geoserver.catalog.LayerGroupVisibilityPolicy.HIDE_NEVER
                // Generate: bean.setProperty(org.geoserver.catalog.LayerGroupVisibilityPolicy.HIDE_NEVER)
                methodBuilder.addStatement("bean.$L($L)", setterName, beanId);
            } else {
                methodBuilder.addComment("// FieldRetrievingFactoryBean with invalid field reference: " + beanId);
            }
        } else {
            // Handle simple nested beans: generate direct instantiation
            // This handles the pattern: <property name="prop"><bean class="com.example.Class"/></property>
            methodBuilder.addStatement("bean.$L(new $L())", setterName, nestedBeanClassName);
        }
    }
}
